##### Comparaison IN/OUT #####

### Preparation ###

# Effacer l'environnement
rm(list = ls())

library(raster)

# Set Wd
internal.wd <- "F:/Documents/Etudes/Fac/Cours/TROPIMUNDO/Stage_S4/Projet_Papillons/R_codes"



# Le fichier est trop lourd donc il faut d'abord le découper sur ArcGIS pour l'alléger

# Création d'un shapefile pour clipper seulement la zone terrestre d'intérêt
res <- "5"
load(file = paste0(internal.wd,"/env",res,".RData"))

crop_mask <- env5[[1]]
crop_mask@data@values[!is.na(crop_mask@data@values)] <- 1
plot(crop_mask)

library(rgeos)
crop_mask_shp <- rasterToPolygons(x = crop_mask, na.rm = T, dissolve=T)
plot(crop_mask_shp, add = T)

save(crop_mask_shp, file = paste0(internal.wd, "/crop_mask_shp.RData"))
load(file = paste0(internal.wd, "/crop_mask_shp.RData"))

library(rgdal)
writeOGR(obj = crop_mask_shp, dsn = paste0(substr(x = internal.wd, start = 0, stop = 66),"/Databases/WDPA_May2019-shapefile"), layer = "crop_mask_shp", driver="ESRI Shapefile") # Pour exporter en vectoriel

### Generate the mask for Ithomiini full range
load(file = paste0(internal.wd,"/Com.sp.richness.RData"))
Ithomiini.range.raster <- tot.sp.richness
Ithomiini.range.raster@data@values[Ithomiini.range.raster@data@values==0] <- NA # Remove pixel with no Ithomiini
Ithomiini.range.raster@data@values[Ithomiini.range.raster@data@values>0] <- 1 # Assign unique value to Ithomiini range
Ithomiini.range <- rasterToPolygons(x = Ithomiini.range.raster, na.rm = T, dissolve=T)
plot(Ithomiini.range)
save(Ithomiini.range.raster, file = paste0(internal.wd, "/Maps_exploitation/Ithomiini_range_raster.RData"))
save(Ithomiini.range, file = paste0(internal.wd, "/Maps_exploitation/Ithomiini_range_shp.RData"))


### Creation des shp des zones protégées

# Charger la carte des zones protégées
# WDPA <- readOGR(dsn = paste0(substr(x = internal.wd, start = 0, stop = 66),"/Databases/WDPA_May2019-shapefile"), layer = "WDPA_May2019-shapefile-polygons")
WDPA_raw <- readOGR(dsn = paste0(substr(x = internal.wd, start = 0, stop = 66),"/Databases/WDPA_May2019-shapefile"), layer = "WDPA_QGIS_test")

# Remove Proposed and Not Reported Status areas
WDPA_raw <- WDPA_raw[!(WDPA_raw$STATUS %in% c("Proposed", "Not Reported")),]
save(WDPA_raw, file = paste0(internal.wd, "/Maps_exploitation/WDPA_raw.RData"))
# plot(WDPA_raw)

# Extract High Status protected areas
WDPA_raw_High_prot <- WDPA_raw[(WDPA_raw$IUCN_CAT %in% c("Ia", "Ib", "II")),]
save(WDPA_raw_High_prot, file = paste0(internal.wd, "/Maps_exploitation/WDPA_raw_High_prot.RData"))
plot(WDPA_raw_High_prot)

# Extract Low Status protected areas
WDPA_raw_Low_prot <- WDPA_raw[(WDPA_raw$IUCN_CAT %in% c("III", "IV", "V", "VI")),]
save(WDPA_raw_Low_prot, file = paste0(internal.wd, "/Maps_exploitation/WDPA_raw_Low_prot.RData"))
plot(WDPA_raw_Low_prot)

# Extract Unknown Status protected areas
WDPA_raw_Unknown_prot <- WDPA_raw[(WDPA_raw$IUCN_CAT %in% c("Not Applicable", "Not Assigned", "Not Reported")),]
save(WDPA_raw_Unknown_prot, file = paste0(internal.wd, "/Maps_exploitation/WDPA_raw_Unknown_prot.RData"))
plot(WDPA_raw_Unknown_prot)


### Crop the full file
library(rgeos)
WDPA_cropped <- gIntersection(spgeom1 = WDPA_raw, spgeom2 = Ithomiini.range, byid = F)
WDPA_High_cropped <- gIntersection(spgeom1 = WDPA_raw_High_prot, spgeom2 = Ithomiini.range, byid = F)
WDPA_Low_cropped <- gIntersection(spgeom1 = WDPA_raw_Low_prot, spgeom2 = Ithomiini.range, byid = F)
WDPA_Unknown_cropped <- gIntersection(spgeom1 = WDPA_raw_Unknown_prot, spgeom2 = Ithomiini.range, byid = F)


### Crop only the shapes (light version)

# Full version
# Pour rendre clean le plot des aires => rasterize puis retransforme en shp en fusionnant
empty_raster <- env5[[1]] ; empty_raster@data@values <- NA
WDPA_raster <- rasterize(x = WDPA_raw, y = empty_raster, field = rep(1, length(WDPA_raw)), fun = max)
plot(WDPA_raster)
WDPA_light <- rasterToPolygons(x = WDPA_raster, na.rm = T, dissolve=T)
WDPA_light_cropped <- gIntersection(spgeom1 = WDPA_light, spgeom2 = Ithomiini.range, byid = F, drop_lower_td = T)
plot(WDPA_light_cropped)
save(WDPA_light_cropped, file = paste0(internal.wd, "/Maps_exploitation/WDPA_light_cropped.RData"))

# High prot areas
empty_raster <- env5[[1]] ; empty_raster@data@values <- NA
WDPA_High_raster <- rasterize(x = WDPA_raw_High_prot, y = empty_raster, field = rep(1, length(WDPA_raw_High_prot)), fun = max)
plot(WDPA_High_raster)
WDPA_light_High <- rasterToPolygons(x = WDPA_High_raster, na.rm = T, dissolve=T)
WDPA_light_cropped_High <- gIntersection(spgeom1 = WDPA_light_High, spgeom2 = Ithomiini.range, byid = F, drop_lower_td = T)
plot(WDPA_light_cropped_High)
save(WDPA_light_cropped_High, file = paste0(internal.wd, "/Maps_exploitation/WDPA_light_cropped_High.RData"))

# Low prot areas
empty_raster <- env5[[1]] ; empty_raster@data@values <- NA
WDPA_Low_raster <- rasterize(x = WDPA_raw_Low_prot, y = empty_raster, field = rep(1, length(WDPA_raw_Low_prot)), fun = max)
plot(WDPA_Low_raster)
WDPA_light_Low <- rasterToPolygons(x = WDPA_Low_raster, na.rm = T, dissolve=T)
WDPA_light_cropped_Low <- gIntersection(spgeom1 = WDPA_light_Low, spgeom2 = Ithomiini.range, byid = F, drop_lower_td = T)
plot(WDPA_light_cropped_Low)
save(WDPA_light_cropped_Low, file = paste0(internal.wd, "/Maps_exploitation/WDPA_light_cropped_Low.RData"))

# Unknown prot areas
empty_raster <- env5[[1]] ; empty_raster@data@values <- NA
WDPA_Unknown_raster <- rasterize(x = WDPA_raw_Unknown_prot, y = empty_raster, field = rep(1, length(WDPA_raw_Unknown_prot)), fun = max)
plot(WDPA_Unknown_raster)
WDPA_light_Unknown <- rasterToPolygons(x = WDPA_Unknown_raster, na.rm = T, dissolve=T)
WDPA_light_cropped_Unknown <- gIntersection(spgeom1 = WDPA_light_Unknown, spgeom2 = Ithomiini.range, byid = F, drop_lower_td = T)
plot(WDPA_light_cropped_Unknown)
save(WDPA_light_cropped_Unknown, file = paste0(internal.wd, "/Maps_exploitation/WDPA_light_cropped_Unknown.RData"))


# Réécriture du CRS avec les arguments dans le même ordre que les autres rasters pour éviter les messages d'erreur
WDPA@proj4string <- CRS(projargs = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0")


### Generate the anti-mask (mask for pixels out of Protected Areas)
library(rgeos)
load(file = paste0(internal.wd, "/Maps_exploitation/Ithomiini_range_shp.RData"))
WDPA_antimask_shp <- gDifference(spgeom1 = Ithomiini.range, spgeom2 = WDPA_light_cropped) # Inverse de l'intersection, conserve les données hors intersection
plot(WDPA_antimask_shp)
save(WDPA_antimask_shp, file = paste0(internal.wd, "/Maps_exploitation/WDPA_antimask_shp.RData"))



### Pre-Analysis of areas

# Projection of light spatial objects for area computation
proj_crop_mask <- spTransform(crop_mask_shp, CRS("+proj=utm +zone=20 +ellps=WGS84 +datum=WGS84 +units=km +no_defs")) # Exemple de projection : "+proj=longlat" pour le WGS84
proj_Ithomiini.range <- spTransform(Ithomiini.range, CRS("+proj=utm +zone=20 +ellps=WGS84 +datum=WGS84 +units=km +no_defs")) # Exemple de projection : "+proj=longlat" pour le WGS84
proj_WDPA_light_cropped <- spTransform(WDPA_light_cropped, CRS("+proj=utm +zone=20 +ellps=WGS84 +datum=WGS84 +units=km +no_defs")) # Exemple de projection : "+proj=longlat" pour le WGS84
proj_WDPA_light_cropped_High <- spTransform(WDPA_light_cropped_High, CRS("+proj=utm +zone=20 +ellps=WGS84 +datum=WGS84 +units=km +no_defs")) # Exemple de projection : "+proj=longlat" pour le WGS84
proj_WDPA_light_cropped_Low <- spTransform(WDPA_light_cropped_Low, CRS("+proj=utm +zone=20 +ellps=WGS84 +datum=WGS84 +units=km +no_defs")) # Exemple de projection : "+proj=longlat" pour le WGS84
proj_WDPA_light_cropped_Unknown <- spTransform(WDPA_light_cropped_Unknown, CRS("+proj=utm +zone=20 +ellps=WGS84 +datum=WGS84 +units=km +no_defs")) # Exemple de projection : "+proj=longlat" pour le WGS84

library(rgeos)

# Compute areas
tot_area <- round(gArea(spgeom = proj_crop_mask, byid = F),0)
Ithomiini.range_area <- round(gArea(spgeom = proj_Ithomiini.range, byid = F),0)
PA_area <- round(gArea(spgeom = proj_WDPA_light_cropped, byid = F),0)
High_area <- round(gArea(spgeom = proj_WDPA_light_cropped_High, byid = F),0)
Low_area <- round(gArea(spgeom = proj_WDPA_light_cropped_Low, byid = F),0)
Unknown_area <- round(gArea(spgeom = proj_WDPA_light_cropped_Unknown, byid = F),0)
save(tot_area, Ithomiini.range_area, PA_area, High_area, Low_area, Unknown_area, file = paste0(internal.wd, "/Maps_exploitation/Areas_values.RData"))

# % of area among Ithomiini range
PA_area/Ithomiini.range_area # 27.9%
High_area/Ithomiini.range_area # 6.3%
Low_area/Ithomiini.range_area # 10.8%
Unknown_area/Ithomiini.range_area # 14.3%

# % of area among PAs
High_area/PA_area # 22.7%
Low_area/PA_area # 38.7%
Unknown_area/PA_area # 51.3%





### Final load
load(file = paste0(internal.wd, "/Maps_exploitation/WDPA_light_cropped.RData"))
load(file = paste0(internal.wd, "/Maps_exploitation/WDPA_antimask_shp.RData"))
WDPA <- WDPA_light_cropped

# Color palet for plot
cool = rainbow(50, s = 1, v = 1, start=rgb2hsv(col2rgb('yellow'))[1], end=rgb2hsv(col2rgb('blue'))[1])
warm = rainbow(50, s = 1, v= 1, start=rgb2hsv(col2rgb('red'))[1], end=rgb2hsv(col2rgb('yellow'))[1])
pal_bl_red  = c(rev(cool), rev(warm))





### Species Richness
load(file = paste0(internal.wd,"/Com.sp.richness.RData"))

# Plot superposé
plot(tot.sp.richness, col = pal_bl_red, main = "Species richness")
plot(WDPA, col = rgb(t(col2rgb(col = "black")), alpha = 0.3), add =T)
plot(crop_mask_shp, add = T)

# Plot par mask
tot.sp.richness.masked <- mask(x = tot.sp.richness, mask = WDPA)
jpeg(filename = paste0(internal.wd,"/Maps/Indices_with_WDPA/WDPA_Sp.richness.jpeg"), quality =100)
plot(tot.sp.richness.masked, col = pal_bl_red, main = "Species richness",
     cex.axis = 1.7, cex.main = 2, axis.args=list(cex.axis=1.7))
plot(crop_mask_shp, add = T)
dev.off()

# Extraire les données du raster dans les buffers IN/OUT WDPA
sp.richness.IN <- na.omit(unlist(extract(tot.sp.richness, WDPA)))
sp.richness.OUT <- na.omit(unlist(extract(tot.sp.richness, WDPA_antimask_shp)))
save(sp.richness.IN, sp.richness.OUT, file = paste0(internal.wd, "/Maps_exploitation/sp.richness.IN.OUT.RData")) 

load(file = paste0(internal.wd, "/Maps_exploitation/sp.richness.IN.OUT.RData")) 
# Faire un sampling aléatoire pour obtenir des données indépendantes spatialement ? 
# Approche bourrine et complexe = SEVF avec neighbor définit par l'appartenance à une même NP (par rapport à l'ID)
# Autre option = autoregression
# Autre option = avec facteur de smooth basé sur les distances entre points => voir Zupan et al., 2014

sampled.sp.richness.IN <- sample(x = sp.richness.IN, size = 1000, replace = F) 
sampled.sp.richness.OUT <- sample(x = sp.richness.OUT, size = 1000, replace = F) 

hist(sampled.sp.richness.IN)
hist(sampled.sp.richness.OUT)

shapiro.test(sampled.sp.richness.IN)
shapiro.test(sampled.sp.richness.OUT)
var.test(sampled.sp.richness.IN, sampled.sp.richness.OUT, alt="two.sided")

wilcox.test(x = sampled.sp.richness.IN, y = sampled.sp.richness.OUT, alternative = "two.sided", paired = F)

# Boxplot
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Boxplots/Boxplot_Sp_richness.jpeg"), quality =100)
boxplot(type = "n", x = cbind(sp.richness.IN, sp.richness.OUT), col = c("limegreen", "grey"), ylab = "Species richness", notch = F, las = 1, names = c("IN","OUT"), main = "Species richness INside or OUTside \n of Protected Areas") 
abline(h=seq(0,100,10),col="grey80", lty="dotted",lwd = 0.4)
abline(v=seq(0,3, 0.25),col="grey80", lty="dotted",lwd = 0.4)
boxplot(add = T , x = cbind(sp.richness.IN, sp.richness.OUT), col = c("limegreen", "grey"), notch = F, las = 1, names = c("IN","OUT")) 
# legend(x = "topleft", legend = c("Wilcox Test", "p < 0.001"))
dev.off()

## Evolution plot
sp.richness_values_df <- data.frame(c(sp.richness.IN, sp.richness.OUT)) ; names(sp.richness_values_df) <-  "values"
sp.richness_values_df$status <- c(rep("IN", length(sp.richness.IN)), rep("OUT", length(sp.richness.OUT)))
sp.richness_values_df <- sp.richness_values_df[order(sp.richness_values_df$values, decreasing = T),]
save(sp.richness_values_df, file = paste0(internal.wd,"/Maps_exploitation/sp.richness_values_df.RData"))

sp.richness_protec_prop <- NA
for (i in 1:100) { # Get the cumulative proportion of protected communities for each %
  N <- round(i*nrow(sp.richness_values_df)/100, 0) # Number of communities to sample
  sample <- sp.richness_values_df$status[1:N] # Extract the top i% communities
  sp.richness_protec_prop[i] <- sum(sample=="IN")/N*100 # Compute the proportion of protected ones
}
save(sp.richness_protec_prop, file = paste0(internal.wd,"/Maps_exploitation/sp.richness_protec_prop.RData"))

# Plot
plot(y = sp.richness_protec_prop, x = 1:100, ylim = c(0, 50), type = "l", lwd = 2, col = "red", 
     ylab = "% of protected communities", main = "Cumulative proportion of protected communities \n ranked from highest to lowest \n Species richness")
abline(h = sp.richness_protec_prop[100], lwd = 2)

## Randomisation Test for X highest %
X <- 20 # 20% highest scoring communities

load(file = paste0(internal.wd,"/Maps_exploitation/sp.richness_protec_prop.RData"))
load(file = paste0(internal.wd,"/Maps_exploitation/sp.richness_values_df.RData"))

sp.richness_20p_obs <- sp.richness_protec_prop[X]

sp.richness_20p_null <- NA
N_Xp <- round(X/100*nrow(sp.richness_values_df),0) # Number of communities to sample to get 20% of them
for (i in 1:999) {
  sample <- sample(x = sp.richness_values_df$status, size = N_Xp, replace = F) # Extract randomly N comm.
  sp.richness_20p_null[i] <- sum(sample=="IN")/N_Xp*100 # Compute the proportion of protected ones
}
save(sp.richness_20p_obs, sp.richness_20p_null, file = paste0(internal.wd,"/Maps_exploitation/sp.richness_20p_values.RData"))

# Plot
load(file = paste0(internal.wd,"/Maps_exploitation/sp.richness_20p_values.RData"))
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Rando_perc_plots/20p_Rando_Sp_Richness.jpeg"), quality = 100)
hist(c(sp.richness_20p_null, sp.richness_20p_obs), 30, freq = TRUE, col = "gray", main = "Distribution of the proportion of protected communities \n among the 20% communities with \n the highest Species Richness \n under the null hypothesis", xlab = "% of protected communities")
arrows(sp.richness_20p_obs - 0.1, 50, sp.richness_20p_obs - 0.1, 5, length = 0.1, lwd = 2)
abline(v = mean(c(sp.richness_20p_null, sp.richness_20p_obs)), lty = 2)
abline(v = quantile(c(sp.richness_20p_null, sp.richness_20p_obs), 0.025), lty = 2, col = "red")
abline(v = quantile(c(sp.richness_20p_null, sp.richness_20p_obs), 0.975), lty = 2, col = "red")
legend(legend = c(paste0("Mean = ", round(mean(c(sp.richness_20p_null, sp.richness_20p_obs)), digits = 1)),
                  paste0("CI 2.5% = ", round(quantile(c(sp.richness_20p_null, sp.richness_20p_obs), 0.025),1)),
                  paste0("CI 97.5% = ", round(quantile(c(sp.richness_20p_null, sp.richness_20p_obs), 0.975),1))), 
       x = "topright", lty = 2 , col = c("black", "red"), cex = 1, bty ="n")
legend(legend = c(paste0("Value obs = ", round(sp.richness_20p_obs, 1)),
                  paste0("             p = ", 1- (ecdf(x = c(sp.richness_20p_null, sp.richness_20p_obs))(sp.richness_20p_obs)))),
       x = "right", cex = 1, bty ="n", xjust = 1)
dev.off()

## Randomisation Test for mean value

sp.richness_obs <- mean(sp.richness.IN)
n.IN <- length(sp.richness.IN) # Number of communities INside PAs

sp.richness_values <- c(sp.richness.IN, sp.richness.OUT)
sp.richness_null <- NA
for (i in 1:999) { # Randomize community protection status 999 times
  sp.richness_null[i] <- mean(sample(x = sp.richness_values, size = n.IN, replace = F)) # Extract mean values from random PAs
}
save(sp.richness_obs, sp.richness_null, file = paste0(internal.wd,"/Maps_exploitation/sp.richness_mean_values.RData"))

# Plot
load(file = paste0(internal.wd,"/Maps_exploitation/sp.richness_mean_values.RData"))
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Rando_plots/Mean_Rando_Sp_Richness.jpeg"), quality = 100)
hist(c(sp.richness_null, sp.richness_obs), 30, freq = TRUE, col = "gray", main = "Distribution of the Mean Species Richness \n under the null hypothesis", xlab = "Species Richness")
arrows(sp.richness_obs - 0.03, 50, sp.richness_obs - 0.03, 5, length = 0.1, lwd = 2)
abline(v = mean(c(sp.richness_null, sp.richness_obs)), lty = 2)
abline(v = quantile(c(sp.richness_null, sp.richness_obs), 0.025), lty = 2, col = "red")
abline(v = quantile(c(sp.richness_null, sp.richness_obs), 0.975), lty = 2, col = "red")
legend(legend = c(paste0("Mean = ", round(mean(c(sp.richness_null, sp.richness_obs)),3)), 
                  paste0("CI 2.5% = ", round(quantile(c(sp.richness_null, sp.richness_obs), 0.025),3)),
                  paste0("CI 97.5% = ", round(quantile(c(sp.richness_null, sp.richness_obs), 0.975),3))), 
       x = "topright", lty = 2 , col = c("black", "red"), cex = 1, bty ="n")
legend(legend = c(paste0("Value obs = ", round(sp.richness_obs, 3)),
                  paste0("             p = ", 1- (ecdf(x = c(sp.richness_null, sp.richness_obs))(sp.richness_obs)))),
       x = "right", cex = 1, bty ="n", xjust = 1)
dev.off()





### Shannon's Species Diversity
load(file = paste0(internal.wd,"/Com.sp.diversity.RData"))

# Plot par mask
sp.diversity.masked <- mask(x = sp.diversity, mask = WDPA)
jpeg(filename = paste0(internal.wd,"/Maps/Indices_with_WDPA/WDPA_Sp.diversity.jpeg"), quality =100)
plot(sp.diversity.masked, col = pal_bl_red, main = "Shannon's Species Diversity",
     cex.axis = 1.7, cex.main = 2, axis.args=list(cex.axis=1.7))
plot(crop_mask_shp, add = T)
dev.off()

# Extraire les données du raster dans les buffers IN/OUT WDPA
sp.diversity.IN <- na.omit(unlist(extract(sp.diversity, WDPA)))
sp.diversity.OUT <- na.omit(unlist(extract(sp.diversity, WDPA_antimask_shp)))
save(sp.diversity.IN, sp.diversity.OUT, file = paste0(internal.wd, "/Maps_exploitation/sp.diversity.IN.OUT.RData")) 

load(file = paste0(internal.wd, "/Maps_exploitation/sp.diversity.IN.OUT.RData")) 
# Faire un sampling aléatoire pour obtenir des données indépendantes spatialement ? 
# Approche bourrine et complexe = SEVF avec nieghbor définit par l'appartenance à une même NP (par rapport à l'ID)
sampled.sp.diversity.IN <- sample(x = sp.diversity.IN, size = 1000, replace = F) 
sampled.sp.diversity.OUT <- sample(x = sp.diversity.OUT, size = 1000, replace = F) 

hist(sampled.sp.diversity.IN)
hist(sampled.sp.diversity.OUT)

shapiro.test(sampled.sp.diversity.IN)
shapiro.test(sampled.sp.diversity.OUT)
var.test(sampled.sp.diversity.IN, sampled.sp.diversity.OUT, alt="two.sided")

wilcox.test(x = sampled.sp.diversity.IN, y = sampled.sp.diversity.OUT, alternative = "two.sided", paired = F)

# Boxplot
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Boxplots/Boxplot_Sp_diversity.jpeg"), quality =100)
boxplot(type = "n", x = cbind(sp.diversity.IN, sp.diversity.OUT), col = c("limegreen", "grey"), notch = F, ylab = "Shannon's Species Diversity Index", main = "Shannon's Species Diversity \n INside or OUTside \n of Protected Areas", las = 1, names = c("IN","OUT")) 
abline(h=seq(0,5,0.5),col="grey80", lty="dotted",lwd = 0.4)
abline(v=seq(0,3, 0.25),col="grey80", lty="dotted",lwd = 0.4)
boxplot(add = T , x = cbind(sp.diversity.IN, sp.diversity.OUT), col = c("limegreen", "grey"), notch = F, las = 1, names = c("IN","OUT")) 
# legend(x = "bottomleft", legend = c("Wilcox Test", "p < 0.001"))
dev.off()

## Evolution plot
sp.diversity_values_df <- data.frame(c(sp.diversity.IN, sp.diversity.OUT)) ; names(sp.diversity_values_df) <-  "values"
sp.diversity_values_df$status <- c(rep("IN", length(sp.diversity.IN)), rep("OUT", length(sp.diversity.OUT)))
sp.diversity_values_df <- sp.diversity_values_df[order(sp.diversity_values_df$values, decreasing = T),]
save(sp.diversity_values_df, file = paste0(internal.wd,"/Maps_exploitation/sp.diversity_values_df.RData"))

sp.diversity_protec_prop <- NA
for (i in 1:100) { # Get the cumulative proportion of protected communities for each %
  N <- round(i*nrow(sp.diversity_values_df)/100, 0) # Number of communities to sample
  sample <- sp.diversity_values_df$status[1:N] # Extract the top i% communities
  sp.diversity_protec_prop[i] <- sum(sample=="IN")/N*100 # Compute the proportion of protected ones
}
save(sp.diversity_protec_prop, file = paste0(internal.wd,"/Maps_exploitation/sp.diversity_protec_prop.RData"))

# Plot
plot(y = sp.diversity_protec_prop, x = 1:100, ylim = c(0, 50), type = "l", lwd = 2, col = "red", 
     ylab = "% of protected communities", main = "Cumulative proportion of protected communities \n ranked from highest to lowest \n Shannon's Species Diversity")
abline(h = sp.diversity_protec_prop[100], lwd = 2)

## Randomisation Test for X highest %
X <- 20 # 20% highest scoring communities

load(file = paste0(internal.wd,"/Maps_exploitation/sp.diversity_protec_prop.RData"))
load(file = paste0(internal.wd,"/Maps_exploitation/sp.diversity_values_df.RData"))

sp.diversity_20p_obs <- sp.diversity_protec_prop[X]

sp.diversity_20p_null <- NA
N_Xp <- round(X/100*nrow(sp.diversity_values_df),0) # Number of communities to sample to get 20% of them
for (i in 1:999) {
  sample <- sample(x = sp.diversity_values_df$status, size = N_Xp, replace = F) # Extract randomly N comm.
  sp.diversity_20p_null[i] <- sum(sample=="IN")/N_Xp*100 # Compute the proportion of protected ones
}
save(sp.diversity_20p_obs, sp.diversity_20p_null, file = paste0(internal.wd,"/Maps_exploitation/sp.diversity_20p_values.RData"))

# Plot
load(file = paste0(internal.wd,"/Maps_exploitation/sp.diversity_20p_values.RData"))
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Rando_perc_plots/20p_Rando_Sp_Diversity.jpeg"), quality = 100)
hist(c(sp.diversity_20p_null, sp.diversity_20p_obs), 30, freq = TRUE, col = "gray", main = "Distribution of the proportion of protected communities \n among the 20% communities with \n the highest Shannon's Species Diversity \n under the null hypothesis", xlab = "% of protected communities")
arrows(sp.diversity_20p_obs + 0, 50, sp.diversity_20p_obs + 0, 5, length = 0.1, lwd = 2)
abline(v = mean(c(sp.diversity_20p_null, sp.diversity_20p_obs)), lty = 2)
abline(v = quantile(c(sp.diversity_20p_null, sp.diversity_20p_obs), 0.025), lty = 2, col = "red")
abline(v = quantile(c(sp.diversity_20p_null, sp.diversity_20p_obs), 0.975), lty = 2, col = "red")
legend(legend = c(paste0("Mean = ", round(mean(c(sp.diversity_20p_null, sp.diversity_20p_obs)), digits = 1)),
                  paste0("CI 2.5% = ", round(quantile(c(sp.diversity_20p_null, sp.diversity_20p_obs), 0.025),1)),
                  paste0("CI 97.5% = ", round(quantile(c(sp.diversity_20p_null, sp.diversity_20p_obs), 0.975),1))), 
       x = "topright", lty = 2 , col = c("black", "red"), cex = 1, bty ="n")
legend(legend = c(paste0("Value obs = ", round(sp.diversity_20p_obs, 1)),
                  paste0("             p = ", 1- (ecdf(x = c(sp.diversity_20p_null, sp.diversity_20p_obs))(sp.diversity_20p_obs)))),
       x = "right", cex = 1, bty ="n", xjust = 1)
dev.off()

## Randomisation Test for mean value
sp.diversity_obs <- mean(sp.diversity.IN)
n.IN <- length(sp.diversity.IN) # Number of communities INside PAs

sp.diversity_values <- c(sp.diversity.IN, sp.diversity.OUT)
sp.diversity_null <- NA
for (i in 1:999) { # Randomize community protection status 999 times
  sp.diversity_null[i] <- mean(sample(x = sp.diversity_values, size = n.IN, replace = F)) # Extract mean values from random PAs
}
save(sp.diversity_obs, sp.diversity_null, file = paste0(internal.wd,"/Maps_exploitation/sp.diversity_mean_values.RData"))

# Plot
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Rando_plots/Mean_Rando_Sp_Diversity.jpeg"), quality = 100)
hist(c(sp.diversity_null, sp.diversity_obs), 30, freq = TRUE, col = "gray", main = "Distribution of the Mean Shannon's Species Diversity \n under the null hypothesis", xlab = "Shannon's Species Diversity Index")
arrows(sp.diversity_obs, 50, sp.diversity_obs, 5, length = 0.1, lwd = 2)
abline(v = mean(c(sp.diversity_null, sp.diversity_obs)), lty = 2)
abline(v = quantile(c(sp.diversity_null, sp.diversity_obs), 0.95), lty = 2, col = "red")
legend(legend = c(paste0("Mean = ", round(mean(c(sp.diversity_null, sp.diversity_obs)),3)), 
                  paste0("CI 95% = ", round(quantile(c(sp.diversity_null, sp.diversity_obs), 0.95),3))), 
       x = "topright", lty = 2 , col = c("black", "red"), cex = 1, bty ="n")
legend(legend = c(paste0("Value obs = ", round(sp.diversity_obs, 3)),
                  paste0("             p = ", 1- (ecdf(x = c(sp.diversity_null, sp.diversity_obs))(sp.diversity_obs)))),
       x = "right", cex = 1, bty ="n", xjust = 1)
dev.off()



### Shannon's Species Diversity (Jost transfo)
load(file = paste0(internal.wd,"/Com.sp.diversity.RData"))
# load(file = paste0(internal.wd,"/Com.sp.diversity.compatible.RData"))
# sp.diversity <- sp.diversity.compatible

# Plot par mask
sp.diversity.masked <- mask(x = exp(sp.diversity), mask = WDPA)
jpeg(filename = paste0(internal.wd,"/Maps/Indices_with_WDPA/WDPA_Sp.diversity_Jost.jpeg"), quality =100)
plot(sp.diversity.masked, col = pal_bl_red, main = "Species Diversity \n (Jost's effective species richness)",
     cex.axis = 1.7, cex.main = 2, axis.args=list(cex.axis=1.7))
plot(crop_mask_shp, add = T)
dev.off()

# Extraire les données du raster dans les buffers IN/OUT WDPA
sp.diversity_Jost.IN <- na.omit(unlist(extract(exp(sp.diversity), WDPA)))
sp.diversity_Jost.OUT <- na.omit(unlist(extract(exp(sp.diversity), WDPA_antimask_shp)))
save(sp.diversity_Jost.IN, sp.diversity_Jost.OUT, file = paste0(internal.wd, "/Maps_exploitation/sp.diversity_Jost.IN.OUT.RData")) 

load(file = paste0(internal.wd, "/Maps_exploitation/sp.diversity_Jost.IN.OUT.RData")) 
# Faire un sampling aléatoire pour obtenir des données indépendantes spatialement ? 
# Approche bourrine et complexe = SEVF avec nieghbor définit par l'appartenance à une même NP (par rapport à l'ID)
sampled.sp.diversity_Jost.IN <- sample(x = sp.diversity_Jost.IN, size = 1000, replace = F) 
sampled.sp.diversity_Jost.OUT <- sample(x = sp.diversity_Jost.OUT, size = 1000, replace = F) 

hist(sampled.sp.diversity_Jost.IN)
hist(sampled.sp.diversity_Jost.OUT)

shapiro.test(sampled.sp.diversity_Jost.IN)
shapiro.test(sampled.sp.diversity_Jost.OUT)
var.test(sampled.sp.diversity_Jost.IN, sampled.sp.diversity_Jost.OUT, alt="two.sided")

wilcox.test(x = sampled.sp.diversity_Jost.IN, y = sampled.sp.diversity_Jost.OUT, alternative = "two.sided", paired = F)

# Boxplot
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Boxplots/Boxplot_Sp_diversity_Jost.jpeg"), quality =100)
boxplot(type = "n", x = cbind(sp.diversity_Jost.IN, sp.diversity_Jost.OUT), col = c("limegreen", "grey"), notch = F, ylab = "Jost's Effective Species Richness", main = "Jost's transformation of \n Shannon's Species Diversity \n INside or OUTside of Protected Areas", las = 1, names = c("IN","OUT")) 
abline(h=seq(0,140,10),col="grey80", lty="dotted",lwd = 0.4)
abline(v=seq(0,3, 0.25),col="grey80", lty="dotted",lwd = 0.4)
boxplot(add = T , x = cbind(sp.diversity_Jost.IN, sp.diversity_Jost.OUT), col = c("limegreen", "grey"), notch = F, las = 1, names = c("IN","OUT")) 
# legend(x = "bottomleft", legend = c("Wilcox Test", "p < 0.001"))
dev.off()

## Evolution plot
sp.diversity_Jost_values_df <- data.frame(c(sp.diversity_Jost.IN, sp.diversity_Jost.OUT)) ; names(sp.diversity_Jost_values_df) <-  "values"
sp.diversity_Jost_values_df$status <- c(rep("IN", length(sp.diversity_Jost.IN)), rep("OUT", length(sp.diversity_Jost.OUT)))
sp.diversity_Jost_values_df <- sp.diversity_Jost_values_df[order(sp.diversity_Jost_values_df$values, decreasing = T),]

sp.diversity_Jost_protec_prop <- NA
for (i in 1:100) { # Get the cumulative proportion of protected communities for each %
  N <- round(i*nrow(sp.diversity_Jost_values_df)/100, 0) # Number of communities to sample
  sample <- sp.diversity_Jost_values_df$status[1:N] # Extract the top i% communities
  sp.diversity_Jost_protec_prop[i] <- sum(sample=="IN")/N*100 # Compute the proportion of protected ones
}
save(sp.diversity_Jost_protec_prop, file = paste0(internal.wd,"/Maps_exploitation/sp.diversity_Jost_protec_prop.RData"))

# Plot
plot(y = sp.diversity_Jost_protec_prop, x = 1:100, ylim = c(0, 50), type = "l", lwd = 2, col = "red", 
     ylab = "% of protected communities", main = "Cumulative proportion of protected communities \n ranked from highest to lowest \n Jost's Effective Species Richness")
abline(h = sp.diversity_Jost_protec_prop[100], lwd = 2)


## Randomisation Test for mean value
sp.diversity_Jost_obs <- mean(sp.diversity_Jost.IN)
n.IN <- length(sp.diversity_Jost.IN) # Number of communities INside PAs

sp.diversity_Jost_values <- c(sp.diversity_Jost.IN, sp.diversity_Jost.OUT)
sp.diversity_Jost_null <- NA
for (i in 1:999) { # Randomize community protection status 999 times
  sp.diversity_Jost_null[i] <- mean(sample(x = sp.diversity_Jost_values, size = n.IN, replace = F)) # Extract mean values from random PAs
}
save(sp.diversity_Jost_obs, sp.diversity_Jost_null, file = paste0(internal.wd,"/Maps_exploitation/sp.diversity_Jost_mean_values.RData"))

# Plot
load(file = paste0(internal.wd,"/Maps_exploitation/sp.diversity_Jost_mean_values.RData"))
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Rando_plots/Mean_Rando_Sp_Diversity_Jost.jpeg"), quality = 100)
hist(c(sp.diversity_Jost_null, sp.diversity_Jost_obs), 30, freq = TRUE, col = "gray", main = "Distribution of the Mean Jost's transformation of \n Shannon's Species Diversity \n under the null hypothesis", xlab = "Jost's Effective Species Richness")
arrows(sp.diversity_Jost_obs - 0.06, 50, sp.diversity_Jost_obs - 0.06, 5, length = 0.1, lwd = 2)
abline(v = mean(c(sp.diversity_Jost_null, sp.diversity_Jost_obs)), lty = 2)
abline(v = quantile(c(sp.diversity_Jost_null, sp.diversity_Jost_obs), 0.025), lty = 2, col = "red")
abline(v = quantile(c(sp.diversity_Jost_null, sp.diversity_Jost_obs), 0.975), lty = 2, col = "red")
legend(legend = c(paste0("Mean = ", round(mean(c(sp.diversity_Jost_null, sp.diversity_Jost_obs)),3)), 
                  paste0("CI 2.5% = ", round(quantile(c(sp.diversity_Jost_null, sp.diversity_Jost_obs), 0.025),3)),
                  paste0("CI 97.5% = ", round(quantile(c(sp.diversity_Jost_null, sp.diversity_Jost_obs), 0.975),3))), 
       x = "topright", lty = 2 , col = c("black", "red"), cex = 1, bty ="n")
legend(legend = c(paste0("Value obs = ", round(sp.diversity_Jost_obs, 3)),
                  paste0("             p = ", 1- (ecdf(x = c(sp.diversity_Jost_null, sp.diversity_Jost_obs))(sp.diversity_Jost_obs)))),
       x = "right", cex = 1, bty ="n", xjust = 1)
dev.off()





### Species Mean Rarity (Species Mean Weighted Richness)
load(file = paste0(internal.wd,"/Com.sp.mean.rarity.RData"))

# Plot par mask
mean.sp.rarity.masked <- mask(x = mean.sp.rarity, mask = WDPA)
jpeg(filename = paste0(internal.wd,"/Maps/Indices_with_WDPA/WDPA_Mean_SP_Rarity.jpeg"), quality =100)
plot(mean.sp.rarity.masked, col = pal_bl_red, main = "Mean Species Rarity",
     cex.axis = 1.7, cex.main = 2, axis.args=list(cex.axis=1.7))
plot(crop_mask_shp, add = T)
dev.off()

# Extraire les données du raster dans les buffers IN/OUT WDPA
mean.sp.rarity.IN <- na.omit(unlist(extract(mean.sp.rarity, WDPA)))
mean.sp.rarity.OUT <- na.omit(unlist(extract(mean.sp.rarity, WDPA_antimask_shp)))
save(mean.sp.rarity.IN, mean.sp.rarity.OUT, file = paste0(internal.wd, "/Maps_exploitation/mean.sp.rarity.IN.OUT.RData")) 

load(file = paste0(internal.wd, "/Maps_exploitation/mean.sp.rarity.IN.OUT.RData")) 
# Faire un sampling aléatoire pour obtenir des données indépendantes spatialement ? 
# Approche bourrine et complexe = SEVF avec nieghbor définit par l'appartenance à une même NP (par rapport à l'ID)
sampled.mean.sp.rarity.IN <- sample(x = mean.sp.rarity.IN, size = 1000, replace = F) 
sampled.mean.sp.rarity.OUT <- sample(x = mean.sp.rarity.OUT, size = 1000, replace = F) 

hist(sampled.mean.sp.rarity.IN)
hist(sampled.mean.sp.rarity.OUT)

shapiro.test(sampled.mean.sp.rarity.IN)
shapiro.test(sampled.mean.sp.rarity.OUT)
var.test(sampled.mean.sp.rarity.IN, sampled.mean.sp.rarity.OUT, alt="two.sided")

wilcox.test(x = sampled.mean.sp.rarity.IN, y = sampled.mean.sp.rarity.OUT, alternative = "two.sided", paired = F)

# Boxplot
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Boxplots/Boxplot_Mean_SP_Rarity.jpeg"), quality = 100)
boxplot(type = "n", x = cbind(mean.sp.rarity.IN, mean.sp.rarity.OUT), col = c("limegreen", "grey"), notch = F, las = 1, ylab = "Mean Species Rarity", main = "Mean Species Rarity \n INside or OUTside of Protected Areas", names = c("IN","OUT")) 
abline(h=seq(0, 1, 0.1),col="grey80", lty="dotted",lwd = 0.4)
abline(v=seq(0,3, 0.25),col="grey80", lty="dotted",lwd = 0.4)
boxplot(add = T , x = cbind(mean.sp.rarity.IN, mean.sp.rarity.OUT), col = c("limegreen", "grey"), notch = F, las = 1, names = c("IN","OUT")) 
# legend(x = "topleft", legend = c("Wilcox Test", "p < 0.001"))
dev.off()

## Evolution plot
mean.sp.rarity_values_df <- data.frame(c(mean.sp.rarity.IN, mean.sp.rarity.OUT)) ; names(mean.sp.rarity_values_df) <-  "values"
mean.sp.rarity_values_df$status <- c(rep("IN", length(mean.sp.rarity.IN)), rep("OUT", length(mean.sp.rarity.OUT)))
mean.sp.rarity_values_df <- mean.sp.rarity_values_df[order(mean.sp.rarity_values_df$values, decreasing = T),]
save(mean.sp.rarity_values_df, file = paste0(internal.wd,"/Maps_exploitation/mean.sp.rarity_values_df.RData"))

mean.sp.rarity_protec_prop <- NA
for (i in 1:100) { # Get the cumulative proportion of protected communities for each %
  N <- round(i*nrow(mean.sp.rarity_values_df)/100, 0) # Number of communities to sample
  sample <- mean.sp.rarity_values_df$status[1:N] # Extract the top i% communities
  mean.sp.rarity_protec_prop[i] <- sum(sample=="IN")/N*100 # Compute the proportion of protected ones
}
save(mean.sp.rarity_protec_prop, file = paste0(internal.wd,"/Maps_exploitation/mean.sp.rarity_protec_prop.RData"))

# Plot
plot(y = mean.sp.rarity_protec_prop, x = 1:100, ylim = c(0, 50), type = "l", lwd = 2, col = "red", 
     ylab = "% of protected communities", main = "Cumulative proportion of protected communities \n ranked from highest to lowest \n Mean Species Rarity")
abline(h = mean.sp.rarity_protec_prop[100], lwd = 2)

## Randomisation Test for X highest %
X <- 20 # 20% highest scoring communities

load(file = paste0(internal.wd,"/Maps_exploitation/mean.sp.rarity_protec_prop.RData"))
load(file = paste0(internal.wd,"/Maps_exploitation/mean.sp.rarity_values_df.RData"))

mean.sp.rarity_20p_obs <- mean.sp.rarity_protec_prop[X]

mean.sp.rarity_20p_null <- NA
N_Xp <- round(X/100*nrow(mean.sp.rarity_values_df),0) # Number of communities to sample to get 20% of them
for (i in 1:999) {
  sample <- sample(x = mean.sp.rarity_values_df$status, size = N_Xp, replace = F) # Extract randomly N comm.
  mean.sp.rarity_20p_null[i] <- sum(sample=="IN")/N_Xp*100 # Compute the proportion of protected ones
}
save(mean.sp.rarity_20p_null, mean.sp.rarity_20p_obs, file = paste0(internal.wd,"/Maps_exploitation/mean.sp.rarity_20p_values.RData"))

# Plot
load(file = paste0(internal.wd,"/Maps_exploitation/mean.sp.rarity_20p_null.RData"))
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Rando_perc_plots/20p_Rando_mean.sp.rarity.jpeg"), quality = 100)
hist(c(mean.sp.rarity_20p_null, mean.sp.rarity_20p_obs), 30, freq = TRUE, col = "gray", main = "Distribution of the proportion of protected communities \n among the 20% communities with \n the highest Mean Species Rarity \n under the null hypothesis", xlab = "% of protected communities")
arrows(mean.sp.rarity_20p_obs + 0, 50, mean.sp.rarity_20p_obs + 0, 5, length = 0.1, lwd = 2)
abline(v = mean(c(mean.sp.rarity_20p_null, mean.sp.rarity_20p_obs)), lty = 2)
abline(v = quantile(c(mean.sp.rarity_20p_null, mean.sp.rarity_20p_obs), 0.025), lty = 2, col = "red")
abline(v = quantile(c(mean.sp.rarity_20p_null, mean.sp.rarity_20p_obs), 0.975), lty = 2, col = "red")
legend(legend = c(paste0("Mean = ", round(mean(c(mean.sp.rarity_20p_null, mean.sp.rarity_20p_obs)), digits = 1)), 
                  paste0("CI 2.5% = ", round(quantile(c(mean.sp.rarity_20p_null, mean.sp.rarity_20p_obs), 0.025),1)),
                  paste0("CI 97.5% = ", round(quantile(c(mean.sp.rarity_20p_null, mean.sp.rarity_20p_obs), 0.975),1))), 
       x = "topleft", lty = 2 , col = c("black", "red"), cex = 1, bty ="n")
legend(legend = c(paste0("Value obs = ", round(mean.sp.rarity_20p_obs, 1)),
                  paste0("    p = ", (ecdf(x = c(mean.sp.rarity_20p_null, mean.sp.rarity_20p_obs))(mean.sp.rarity_20p_obs)))),
       x = "left", cex = 1, bty ="n", xjust = 1)
dev.off()

## Randomisation Test for mean value
mean.sp.rarity_obs <- mean(mean.sp.rarity.IN)
n.IN <- length(mean.sp.rarity.IN) # Number of communities INside PAs

mean.sp.rarity_values <- c(mean.sp.rarity.IN, mean.sp.rarity.OUT)
mean.sp.rarity_null <- NA
for (i in 1:999) { # Randomize community protection status 999 times
  mean.sp.rarity_null[i] <- mean(sample(x = mean.sp.rarity_values, size = n.IN, replace = F)) # Extract mean values from random PAs
}
save(mean.sp.rarity_obs, mean.sp.rarity_null, file = paste0(internal.wd,"/Maps_exploitation/mean.sp.rarity_mean_values.RData"))

# Plot
load(file = paste0(internal.wd,"/Maps_exploitation/mean.sp.rarity_mean_values.RData"))
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Rando_plots/Mean_Rando_Average_SP_Rarity.jpeg"), quality = 100)
hist(c(mean.sp.rarity_null, mean.sp.rarity_obs), 30, freq = TRUE, col = "gray", main = "Distribution of the Mean Average Species Rarity \n under the null hypothesis", xlab = "Mean Species Rarity")
arrows(mean.sp.rarity_obs + 0.0001, 35, mean.sp.rarity_obs+ 0.0001, 10, length = 0.1, lwd = 2)
abline(v = mean(c(mean.sp.rarity_null, mean.sp.rarity_obs)), lty = 2)
abline(v = quantile(c(mean.sp.rarity_null, mean.sp.rarity_obs), 0.025), lty = 2, col = "red")
abline(v = quantile(c(mean.sp.rarity_null, mean.sp.rarity_obs), 0.975), lty = 2, col = "red")
legend(legend = c(paste0("Mean = ", round(mean(c(mean.sp.rarity_null, mean.sp.rarity_obs)),3)), 
                  paste0("CI 2.5% = ", round(quantile(c(mean.sp.rarity_null, mean.sp.rarity_obs), 0.025),3)),
                  paste0("CI 97.5% = ", round(quantile(c(mean.sp.rarity_null, mean.sp.rarity_obs), 0.975),3))), 
       x = "topright", lty = 2 , col = c("black", "red"), cex = 1, bty ="n")
legend(legend = c("Value obs", paste0("   ", round(mean.sp.rarity_obs, 3)),
                  paste0(" p = ", (ecdf(x = c(mean.sp.rarity_null, mean.sp.rarity_obs))(mean.sp.rarity_obs)))),
       x = "left", cex = 1, bty ="n", xjust = 1)
dev.off()




### Faith's Phylogenetic Diversity
load(file = paste0(internal.wd,"/Com.PD.RData"))

# Plot par mask
PD.raster.masked <- mask(x = PD.raster, mask = WDPA)
jpeg(filename = paste0(internal.wd,"/Maps/Indices_with_WDPA/WDPA_Faith.PD.jpeg"), quality =100)
plot(PD.raster.masked, col = pal_bl_red, main = "Faith's Phylogenetic Diversity",
     cex.axis = 1.7, cex.main = 2, axis.args=list(cex.axis=1.7))
plot(crop_mask_shp, add = T)
dev.off()

# Extraire les données du raster dans les buffers IN/OUT WDPA
Faith.PD.IN <- na.omit(unlist(extract(PD.raster, WDPA)))
Faith.PD.OUT <- na.omit(unlist(extract(PD.raster, WDPA_antimask_shp)))
save(Faith.PD.IN, Faith.PD.OUT, file = paste0(internal.wd, "/Maps_exploitation/Faith.PD.IN.OUT.RData")) 

load(file = paste0(internal.wd, "/Maps_exploitation/Faith.PD.IN.OUT.RData")) 
# Faire un sampling aléatoire pour obtenir des données indépendantes spatialement ? 
# Approche bourrine et complexe = SEVF avec nieghbor définit par l'appartenance à une même NP (par rapport à l'ID)
sampled.Faith.PD.IN <- sample(x = Faith.PD.IN, size = 1000, replace = F) 
sampled.Faith.PD.OUT <- sample(x = Faith.PD.OUT, size = 1000, replace = F) 

hist(sampled.Faith.PD.IN)
hist(sampled.Faith.PD.OUT)

shapiro.test(sampled.Faith.PD.IN)
shapiro.test(sampled.Faith.PD.OUT)
var.test(sampled.Faith.PD.IN, sampled.Faith.PD.OUT, alt="two.sided")

wilcox.test(x = sampled.Faith.PD.IN, y = sampled.Faith.PD.OUT, alternative = "two.sided", paired = F)

# Boxplot
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Boxplots/Boxplot_Faith_PD.jpeg"), quality =100)
boxplot(type = "n", x = cbind(Faith.PD.IN, Faith.PD.OUT), col = c("limegreen", "grey"), notch = F, las = 1, ylab = "Faith's Phylogenetic Diversity (My)", main = "Faith's Phylogenetic Diversity \n INside or OUTside of Protected Areas", names = c("IN","OUT")) 
abline(h=seq(0,800,100),col="grey80", lty="dotted",lwd = 0.4)
abline(v=seq(0,3, 0.25),col="grey80", lty="dotted",lwd = 0.4)
boxplot(add = T , x = cbind(Faith.PD.IN, Faith.PD.OUT), col = c("limegreen", "grey"), notch = F, las = 1, names = c("IN","OUT")) 
# legend(x = "topleft", legend = c("Wilcox Test", "p < 0.001"))
dev.off()

## Evolution plot
Faith.PD_values_df <- data.frame(c(Faith.PD.IN, Faith.PD.OUT)) ; names(Faith.PD_values_df) <-  "values"
Faith.PD_values_df$status <- c(rep("IN", length(Faith.PD.IN)), rep("OUT", length(Faith.PD.OUT)))
Faith.PD_values_df <- Faith.PD_values_df[order(Faith.PD_values_df$values, decreasing = T),]
save(Faith.PD_values_df, file = paste0(internal.wd,"/Maps_exploitation/Faith.PD_values_df.RData"))


Faith.PD_protec_prop <- NA
for (i in 1:100) { # Get the cumulative proportion of protected communities for each %
  N <- round(i*nrow(Faith.PD_values_df)/100, 0) # Number of communities to sample
  sample <- Faith.PD_values_df$status[1:N] # Extract the top i% communities
  Faith.PD_protec_prop[i] <- sum(sample=="IN")/N*100 # Compute the proportion of protected ones
}
save(Faith.PD_protec_prop, file = paste0(internal.wd,"/Maps_exploitation/Faith.PD_protec_prop.RData"))

# Plot
plot(y = Faith.PD_protec_prop, x = 1:100, ylim = c(0, 50), type = "l", lwd = 2, col = "red", 
     ylab = "% of protected communities", main = "Cumulative proportion of protected communities \n ranked from highest to lowest \n Faith's Phylogenetic Diversity")
abline(h = Faith.PD_protec_prop[100], lwd = 2)

## Randomisation Test for X highest %
X <- 20 # 20% highest scoring communities

load(file = paste0(internal.wd,"/Maps_exploitation/Faith.PD_protec_prop.RData"))
load(file = paste0(internal.wd,"/Maps_exploitation/Faith.PD_values_df.RData"))

Faith.PD_20p_obs <- Faith.PD_protec_prop[X]

Faith.PD_20p_null <- NA
N_Xp <- round(X/100*nrow(Faith.PD_values_df),0) # Number of communities to sample to get 20% of them
for (i in 1:999) {
  sample <- sample(x = Faith.PD_values_df$status, size = N_Xp, replace = F) # Extract randomly N comm.
  Faith.PD_20p_null[i] <- sum(sample=="IN")/N_Xp*100 # Compute the proportion of protected ones
}
save(Faith.PD_20p_obs, Faith.PD_20p_null, file = paste0(internal.wd,"/Maps_exploitation/Faith.PD_20p_values.RData"))

# Plot
load(file = paste0(internal.wd,"/Maps_exploitation/Faith.PD_20p_values.RData"))
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Rando_perc_plots/20p_Rando_Faith.PD.jpeg"), quality = 100)
hist(c(Faith.PD_20p_null, Faith.PD_20p_obs), 30, freq = TRUE, col = "gray", main = "Distribution of the proportion of protected communities \n among the 20% communities with \n the highest Faith's Phylogenetic Diversity \n under the null hypothesis", xlab = "% of protected communities")
arrows(Faith.PD_20p_obs + 0, 50, Faith.PD_20p_obs + 0, 5, length = 0.1, lwd = 2)
abline(v = mean(c(Faith.PD_20p_null, Faith.PD_20p_obs)), lty = 2)
abline(v = quantile(c(Faith.PD_20p_null, Faith.PD_20p_obs), 0.025), lty = 2, col = "red")
abline(v = quantile(c(Faith.PD_20p_null, Faith.PD_20p_obs), 0.975), lty = 2, col = "red")
legend(legend = c(paste0("Mean = ", round(mean(c(Faith.PD_20p_null, Faith.PD_20p_obs)), digits = 1)),
                  paste0("CI 2.5% = ", round(quantile(c(Faith.PD_20p_null, Faith.PD_20p_obs), 0.025),1)),
                  paste0("CI 97.5% = ", round(quantile(c(Faith.PD_20p_null, Faith.PD_20p_obs), 0.975),1))), 
       x = "topright", lty = 2 , col = c("black", "red"), cex = 1, bty ="n")
legend(legend = c(paste0("Value obs = ", round(Faith.PD_20p_obs, 1)),
                  paste0("             p = ", 1- (ecdf(x = c(Faith.PD_20p_null, Faith.PD_20p_obs))(Faith.PD_20p_obs)))),
       x = "right", cex = 1, bty ="n", xjust = 1)
dev.off()

## Randomisation Test for mean value
Faith.PD_obs <- mean(Faith.PD.IN)
n.IN <- length(Faith.PD.IN) # Number of communities INside PAs

Faith.PD_values <- c(Faith.PD.IN, Faith.PD.OUT)
Faith.PD_null <- NA
for (i in 1:999) { # Randomize community protection status 999 times
  Faith.PD_null[i] <- mean(sample(x = Faith.PD_values, size = n.IN, replace = F)) # Extract mean values from random PAs
}
save(Faith.PD_obs, Faith.PD_null, file = paste0(internal.wd,"/Maps_exploitation/Faith.PD_mean_values.RData"))

# Plot
load(file = paste0(internal.wd,"/Maps_exploitation/Faith.PD_mean_values.RData"))
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Rando_plots/Mean_Rando_Faith.PD.jpeg"), quality = 100)
hist(c(Faith.PD_null, Faith.PD_obs), 30, freq = TRUE, col = "gray", main = "Distribution of the Mean Faith's Phylogenetic Diversity \n under the null hypothesis", xlab = "Faith's Phylogenetic Diversity (My)")
arrows(Faith.PD_obs + 0.0001, 80, Faith.PD_obs+ 0.0001, 10, length = 0.1, lwd = 2)
abline(v = mean(c(Faith.PD_null, Faith.PD_obs)), lty = 2)
abline(v = quantile(c(Faith.PD_null, Faith.PD_obs), 0.025), lty = 2, col = "red")
abline(v = quantile(c(Faith.PD_null, Faith.PD_obs), 0.975), lty = 2, col = "red")
legend(legend = c(paste0("Mean = ", round(mean(c(Faith.PD_null, Faith.PD_obs)),3)), 
                  paste0("CI 2.5% = ", round(quantile(c(Faith.PD_null, Faith.PD_obs), 0.025),3)),
                  paste0("CI 97.5% = ", round(quantile(c(Faith.PD_null, Faith.PD_obs), 0.975),3))), 
       x = "topright", lty = 2 , col = c("black", "red"), cex = 1, bty ="n")
legend(legend = c(paste0("Value obs = ", round(Faith.PD_obs, 3)),
                  paste0("                  p = ", 1-(ecdf(x = c(Faith.PD_null, Faith.PD_obs))(Faith.PD_obs)))),
       x = "right", cex = 1, bty ="n", xjust = 1)
dev.off()





### Mean Pairwise Phylogenetic Distance
load(file = paste0(internal.wd,"/Com.MPD.RData"))
load(file = paste0(internal.wd,"/MPD.contrasted.RData"))

# Plot par mask
MPD.raster.masked <- mask(x = MPD.raster.contrasted, mask = WDPA)
jpeg(filename = paste0(internal.wd,"/Maps/Indices_with_WDPA/WDPA_MPD_contrasted.jpeg"), quality =100)
plot(MPD.raster.masked, col = pal_bl_red, main = "Mean pairwise Phylogenetic Distance",
     cex.axis = 1.7, cex.main = 2, axis.args=list(cex.axis=1.7))
plot(crop_mask_shp, add = T)
dev.off()

# Extraire les données du raster dans les buffers IN/OUT WDPA
MPD.IN <- na.omit(unlist(extract(MPD.raster, WDPA)))
MPD.OUT <- na.omit(unlist(extract(MPD.raster, WDPA_antimask_shp)))
save(MPD.IN, MPD.OUT, file = paste0(internal.wd, "/Maps_exploitation/MPD.IN.OUT.RData")) 

load(file = paste0(internal.wd, "/Maps_exploitation/MPD.IN.OUT.RData")) 
# Faire un sampling aléatoire pour obtenir des données indépendantes spatialement ? 
# Approche bourrine et complexe = SEVF avec nieghbor définit par l'appartenance à une même NP (par rapport à l'ID)
sampled.MPD.IN <- sample(x = MPD.IN, size = 1000, replace = F) 
sampled.MPD.OUT <- sample(x = MPD.OUT, size = 1000, replace = F) 

hist(sampled.MPD.IN)
hist(sampled.MPD.OUT)

shapiro.test(sampled.MPD.IN)
shapiro.test(sampled.MPD.OUT)
var.test(sampled.MPD.IN, sampled.MPD.OUT, alt="two.sided")

wilcox.test(x = sampled.MPD.IN, y = sampled.MPD.OUT, alternative = "two.sided", paired = F)

# Boxplot
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Boxplots/Boxplot_MPD.jpeg"), quality =100)
boxplot(type = "n", x = cbind(MPD.IN, MPD.OUT), col = c("limegreen", "grey"), notch = F, las = 1, ylab = "Mean Pairwise Phylogenetic Distance (My)", main = "Mean Pairwise Phylogenetic Distance \n INside or OUTside of Protected Areas", names = c("IN","OUT")) 
abline(h=seq(0,50,5),col="grey80", lty="dotted",lwd = 0.4)
abline(v=seq(0,3, 0.25),col="grey80", lty="dotted",lwd = 0.4)
boxplot(add = T , x = cbind(MPD.IN, MPD.OUT), col = c("limegreen", "grey"), notch = F, las = 1, names = c("IN","OUT")) 
# legend(x = "topleft", legend = c("Wilcox Test", "p < 0.001"))
dev.off()

## Evolution plot
MPD_values_df <- data.frame(c(MPD.IN, MPD.OUT)) ; names(MPD_values_df) <-  "values"
MPD_values_df$status <- c(rep("IN", length(MPD.IN)), rep("OUT", length(MPD.OUT)))
MPD_values_df <- MPD_values_df[order(MPD_values_df$values, decreasing = T),]
save(MPD_values_df, file = paste0(internal.wd,"/Maps_exploitation/MPD_values_df.RData"))

MPD_protec_prop <- NA
for (i in 1:100) { # Get the cumulative proportion of protected communities for each %
  N <- round(i*nrow(MPD_values_df)/100, 0) # Number of communities to sample
  sample <- MPD_values_df$status[1:N] # Extract the top i% communities
  MPD_protec_prop[i] <- sum(sample=="IN")/N*100 # Compute the proportion of protected ones
}
save(MPD_protec_prop, file = paste0(internal.wd,"/Maps_exploitation/MPD_protec_prop.RData"))

# Plot
plot(y = MPD_protec_prop, x = 1:100, ylim = c(0, 50), type = "l", lwd = 2, col = "red", 
     ylab = "% of protected communities", main = "Cumulative proportion of protected communities \n ranked from highest to lowest \n Mean Pairwise Phylogenetic Distance")
abline(h = MPD_protec_prop[100], lwd = 2)

## Randomisation Test for X highest %
X <- 20 # 20% highest scoring communities

load(file = paste0(internal.wd,"/Maps_exploitation/MPD_protec_prop.RData"))
load(file = paste0(internal.wd,"/Maps_exploitation/MPD_values_df.RData"))

MPD_20p_obs <- MPD_protec_prop[X]

MPD_20p_null <- NA
N_Xp <- round(X/100*nrow(MPD_values_df),0) # Number of communities to sample to get 20% of them
for (i in 1:999) {
  sample <- sample(x = MPD_values_df$status, size = N_Xp, replace = F) # Extract randomly N comm.
  MPD_20p_null[i] <- sum(sample=="IN")/N_Xp*100 # Compute the proportion of protected ones
}
save(MPD_20p_obs, MPD_20p_null, file = paste0(internal.wd,"/Maps_exploitation/MPD_20p_values.RData"))

# Plot
load(file = paste0(internal.wd,"/Maps_exploitation/MPD_20p_values.RData"))
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Rando_perc_plots/20p_Rando_MPD.jpeg"), quality = 100)
hist(c(MPD_20p_null, MPD_20p_obs), 30, freq = TRUE, col = "gray", main = "Distribution of the proportion of protected communities \n among the 20% communities with \n the highest MPD \n under the null hypothesis", xlab = "% of protected communities")
arrows(MPD_20p_obs + 0.15, 50, MPD_20p_obs + 0.15, 5, length = 0.1, lwd = 2)
abline(v = mean(c(MPD_20p_null, MPD_20p_obs)), lty = 2)
abline(v = quantile(c(MPD_20p_null, MPD_20p_obs), 0.025), lty = 2, col = "red")
abline(v = quantile(c(MPD_20p_null, MPD_20p_obs), 0.975), lty = 2, col = "red")
legend(legend = c(paste0("Mean = ", round(mean(c(MPD_20p_null, MPD_20p_obs)), digits = 1)),
                  paste0("CI 2.5% = ", round(quantile(c(MPD_20p_null, MPD_20p_obs), 0.025),1)),
                  paste0("CI 97.5% = ", round(quantile(c(MPD_20p_null, MPD_20p_obs), 0.975),1))), 
       x = "topright", lty = 2 , col = c("black", "red"), cex = 1, bty ="n")
legend(legend = c(paste0("Value obs = ", round(MPD_20p_obs, 1)),
                  paste0("             p = ", 1- (ecdf(x = c(MPD_20p_null, MPD_20p_obs))(MPD_20p_obs)))),
       x = "right", cex = 1, bty ="n", xjust = 1)
dev.off()

## Randomisation Test for mean value
MPD_obs <- mean(MPD.IN)
n.IN <- length(MPD.IN) # Number of communities INside PAs

MPD_values <- c(MPD.IN, MPD.OUT)
MPD_null <- NA
for (i in 1:999) { # Randomize community protection status 999 times
  MPD_null[i] <- mean(sample(x = MPD_values, size = n.IN, replace = F)) # Extract mean values from random PAs
}
save(MPD_obs, MPD_null, file = paste0(internal.wd,"/Maps_exploitation/MPD_mean_values.RData"))

# Plot
load(file = paste0(internal.wd,"/Maps_exploitation/MPD_mean_values.RData"))
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Rando_plots/Mean_Rando_MPD.jpeg"), quality = 100)
hist(c(MPD_null, MPD_obs), 30, freq = TRUE, col = "gray", main = "Distribution of the Mean Average Pairwise Phylogenetic Distance \n under the null hypothesis", xlab = "Mean Pairwise Phylogenetic Distance (My)")
arrows(MPD_obs + 0.0001, 80, MPD_obs+ 0.0001, 10, length = 0.1, lwd = 2)
abline(v = mean(c(MPD_null, MPD_obs)), lty = 2)
abline(v = quantile(c(MPD_null, MPD_obs), 0.025), lty = 2, col = "red")
abline(v = quantile(c(MPD_null, MPD_obs), 0.975), lty = 2, col = "red")
legend(legend = c(paste0("Mean = ", round(mean(c(MPD_null, MPD_obs)),3)), 
                  paste0("CI 2.5% = ", round(quantile(c(MPD_null, MPD_obs), 0.025),3)),
                  paste0("CI 97.5% = ", round(quantile(c(MPD_null, MPD_obs), 0.975),3))), 
       x = "topright", lty = 2 , col = c("black", "red"), cex = 1, bty ="n")
legend(legend = c(paste0("Value obs = ", round(MPD_obs, 3)),
                  paste0("                  p = ", 1-(ecdf(x = c(MPD_null, MPD_obs))(MPD_obs)))),
       x = "right", cex = 1, bty ="n", xjust = 1)
dev.off()




### Sum of Fair proportion
load(file = paste0(internal.wd,"/Com.FP.RData"))

# Plot par mask
FP.raster.masked <- mask(x = FP.raster, mask = WDPA)
jpeg(filename = paste0(internal.wd,"/Maps/Indices_with_WDPA/WDPA_FP.jpeg"), quality = 100)
plot(FP.raster.masked, col = pal_bl_red, main = "Sum of Fair-Proportion",
     cex.axis = 1.7, cex.main = 2, axis.args=list(cex.axis=1.7))
plot(crop_mask_shp, add = T)
dev.off()

# Extraire les données du raster dans les buffers IN/OUT WDPA
FP.IN <- na.omit(unlist(extract(FP.raster, WDPA)))
FP.OUT <- na.omit(unlist(extract(FP.raster, WDPA_antimask_shp)))
save(FP.IN, FP.OUT, file = paste0(internal.wd, "/Maps_exploitation/FP.IN.OUT.RData")) 

load(file = paste0(internal.wd, "/Maps_exploitation/FP.IN.OUT.RData")) 
# Faire un sampling aléatoire pour obtenir des données indépendantes spatialement ? 
# Approche bourrine et complexe = SEVF avec nieghbor définit par l'appartenance à une même NP (par rapport à l'ID)
sampled.FP.IN <- sample(x = FP.IN, size = 1000, replace = F) 
sampled.FP.OUT <- sample(x = FP.OUT, size = 1000, replace = F) 

hist(sampled.FP.IN)
hist(sampled.FP.OUT)

shapiro.test(sampled.FP.IN)
shapiro.test(sampled.FP.OUT)
var.test(sampled.FP.IN, sampled.FP.OUT, alt="two.sided")

wilcox.test(x = sampled.FP.IN, y = sampled.FP.OUT, alternative = "two.sided", paired = F)

# Boxplot
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Boxplots/Boxplot_FP.jpeg"), quality = 100)
boxplot(type = "n", x = cbind(FP.IN, FP.OUT), col = c("limegreen", "grey"), notch = F, las = 1, ylab = "Sum of Species Fair-Proportion (My)", main = "Sum of Species Fair-Proportion \n INside or OUTside of Protected Areas", names = c("IN","OUT")) 
abline(h=seq(0, 500, 50),col="grey80", lty="dotted",lwd = 0.4)
abline(v=seq(0, 3, 0.25),col="grey80", lty="dotted",lwd = 0.4)
boxplot(add = T , x = cbind(FP.IN, FP.OUT), col = c("limegreen", "grey"), notch = F, las = 1, names = c("IN","OUT")) 
# legend(x = "topleft", legend = c("Wilcox Test", "p < 0.001"))
dev.off()

## Evolution plot
FP_values_df <- data.frame(c(FP.IN, FP.OUT)) ; names(FP_values_df) <-  "values"
FP_values_df$status <- c(rep("IN", length(FP.IN)), rep("OUT", length(FP.OUT)))
FP_values_df <- FP_values_df[order(FP_values_df$values, decreasing = T),]
save(FP_values_df, file = paste0(internal.wd,"/Maps_exploitation/FP_values_df.RData"))

FP_protec_prop <- NA
for (i in 1:100) { # Get the cumulative proportion of protected communities for each %
  N <- round(i*nrow(FP_values_df)/100, 0) # Number of communities to sample
  sample <- FP_values_df$status[1:N] # Extract the top i% communities
  FP_protec_prop[i] <- sum(sample=="IN")/N*100 # Compute the proportion of protected ones
}
save(FP_protec_prop, file = paste0(internal.wd,"/Maps_exploitation/FP_protec_prop.RData"))

# Plot
plot(y = FP_protec_prop, x = 1:100, ylim = c(0, 50), type = "l", lwd = 2, col = "red", 
     ylab = "% of protected communities", main = "Cumulative proportion of protected communities \n ranked from highest to lowest \n Sum of Species Fair-Proportion")
abline(h = FP_protec_prop[100], lwd = 2)

## Randomisation Test for X highest %
X <- 20 # 20% highest scoring communities

load(file = paste0(internal.wd,"/Maps_exploitation/FP_protec_prop.RData"))
load(file = paste0(internal.wd,"/Maps_exploitation/FP_values_df.RData"))

FP_20p_obs <- FP_protec_prop[X]

FP_20p_null <- NA
N_Xp <- round(X/100*nrow(FP_values_df),0) # Number of communities to sample to get 20% of them
for (i in 1:999) {
  sample <- sample(x = FP_values_df$status, size = N_Xp, replace = F) # Extract randomly N comm.
  FP_20p_null[i] <- sum(sample=="IN")/N_Xp*100 # Compute the proportion of protected ones
}
save(FP_20p_obs, FP_20p_null, file = paste0(internal.wd,"/Maps_exploitation/FP_20p_values.RData"))

# Plot
load(file = paste0(internal.wd,"/Maps_exploitation/FP_20p_values.RData"))
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Rando_perc_plots/20p_Rando_FP.jpeg"), quality = 100)
hist(c(FP_20p_null, FP_20p_obs), 30, freq = TRUE, col = "gray", main = "Distribution of the proportion of protected communities \n among the 20% communities with \n the highest Sum of Species Fair-Proportion \n under the null hypothesis", xlab = "% of protected communities")
arrows(FP_20p_obs - 0.07, 50, FP_20p_obs - 0.07, 5, length = 0.1, lwd = 2)
abline(v = mean(c(FP_20p_null, FP_20p_obs)), lty = 2)
abline(v = quantile(c(FP_20p_null, FP_20p_obs), 0.025), lty = 2, col = "red")
abline(v = quantile(c(FP_20p_null, FP_20p_obs), 0.975), lty = 2, col = "red")
legend(legend = c(paste0("Mean = ", round(mean(c(FP_20p_null, FP_20p_obs)), digits = 1)),
                  paste0("CI 2.5% = ", round(quantile(c(FP_20p_null, FP_20p_obs), 0.025),1)),
                  paste0("CI 97.5% = ", round(quantile(c(FP_20p_null, FP_20p_obs), 0.975),1))), 
       x = "topright", lty = 2 , col = c("black", "red"), cex = 1, bty ="n")
legend(legend = c(paste0("Value obs = ", round(FP_20p_obs, 1)),
                  paste0("             p = ", 1- (ecdf(x = c(FP_20p_null, FP_20p_obs))(FP_20p_obs)))),
       x = "right", cex = 1, bty ="n", xjust = 1)
dev.off()

## Randomisation Test for mean value
FP_obs <- mean(FP.IN)
n.IN <- length(FP.IN) # Number of communities INside PAs

FP_values <- c(FP.IN, FP.OUT)
FP_null <- NA
for (i in 1:999) { # Randomize community protection status 999 times
  FP_null[i] <- mean(sample(x = FP_values, size = n.IN, replace = F)) # Extract mean values from random PAs
}
save(FP_obs, FP_null, file = paste0(internal.wd,"/Maps_exploitation/FP_mean_values.RData"))

# Plot
load(file = paste0(internal.wd,"/Maps_exploitation/FP_mean_values.RData"))
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Rando_plots/Mean_Rando_FP.jpeg"), quality = 100)
hist(c(FP_null, FP_obs), 30, freq = TRUE, col = "gray", main = "Distribution of the Mean Sum of Species Fair-Proportion \n under the null hypothesis", xlab = "Sum of Species Fair-Proportion (My)")
arrows(FP_obs + 0.2, 80, FP_obs+ 0.2, 10, length = 0.1, lwd = 2)
abline(v = mean(c(FP_null, FP_obs)), lty = 2)
abline(v = quantile(c(FP_null, FP_obs), 0.025), lty = 2, col = "red")
abline(v = quantile(c(FP_null, FP_obs), 0.975), lty = 2, col = "red")
legend(legend = c(paste0("Mean = ", round(mean(c(FP_null, FP_obs)),3)), 
                  paste0("CI 2.5% = ", round(quantile(c(FP_null, FP_obs), 0.025),3)),
                  paste0("CI 97.5% = ", round(quantile(c(FP_null, FP_obs), 0.975),3))), 
       x = "topright", lty = 2 , col = c("black", "red"), cex = 1, bty ="n")
legend(legend = c(paste0("Value obs = ", round(FP_obs, 3)),
                  paste0("                  p = ", 1-(ecdf(x = c(FP_null, FP_obs))(FP_obs)))),
       x = "right", cex = 1, bty ="n", xjust = 1)
dev.off()




### Mimicry Richness
load(file = paste0(internal.wd,"/Com.ring.richness.RData"))

# Plot par mask
tot.ring.richness.masked <- mask(x = tot.ring.richness, mask = WDPA)
jpeg(filename = paste0(internal.wd,"/Maps/Indices_with_WDPA/WDPA_Mimicry_Richness.jpeg"), quality = 100)
plot(tot.ring.richness.masked, col = pal_bl_red, main = "Mimicry Richness",
     cex.axis = 1.7, cex.main = 2, axis.args=list(cex.axis=1.7))
plot(crop_mask_shp, add = T)
dev.off()

# Extraire les données du raster dans les buffers IN/OUT WDPA
Mimicry.richness.IN <- na.omit(unlist(extract(tot.ring.richness, WDPA)))
Mimicry.richness.OUT <- na.omit(unlist(extract(tot.ring.richness, WDPA_antimask_shp)))
save(Mimicry.richness.IN, Mimicry.richness.OUT, file = paste0(internal.wd, "/Maps_exploitation/Mimicry.richness.IN.OUT.RData")) 

load(file = paste0(internal.wd, "/Maps_exploitation/Mimicry.richness.IN.OUT.RData")) 
# Faire un sampling aléatoire pour obtenir des données indépendantes spatialement ? 
# Approche bourrine et complexe = SEVF avec nieghbor définit par l'appartenance à une même NP (par rapport à l'ID)
sampled.Mimicry.richness.IN <- sample(x = Mimicry.richness.IN, size = 1000, replace = F) 
sampled.Mimicry.richness.OUT <- sample(x = Mimicry.richness.OUT, size = 1000, replace = F) 

hist(sampled.Mimicry.richness.IN)
hist(sampled.Mimicry.richness.OUT)

shapiro.test(sampled.Mimicry.richness.IN)
shapiro.test(sampled.Mimicry.richness.OUT)
var.test(sampled.Mimicry.richness.IN, sampled.Mimicry.richness.OUT, alt="two.sided")

wilcox.test(x = sampled.Mimicry.richness.IN, y = sampled.Mimicry.richness.OUT, alternative = "two.sided", paired = F)

# Boxplot
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Boxplots/Boxplot_Mimicry_Richness.jpeg"), quality = 100)
boxplot(type = "n", x = cbind(Mimicry.richness.IN, Mimicry.richness.OUT), col = c("limegreen", "grey"), notch = F, las = 1, ylab = "Mimicry Richness (Nb of mimicry rings)", main = "Mimicry Richness \n (Nb of mimicry rings)  \n INside or OUTside of Protected Areas", names = c("IN","OUT")) 
abline(h=seq(0, 25, 3),col="grey80", lty="dotted",lwd = 0.4)
abline(v=seq(0, 3, 0.25),col="grey80", lty="dotted",lwd = 0.4)
boxplot(add = T , x = cbind(Mimicry.richness.IN, Mimicry.richness.OUT), col = c("limegreen", "grey"), notch = F, las = 1, names = c("IN","OUT")) 
# legend(x = "topleft", legend = c("Wilcox Test", "p < 0.001"))
dev.off()

## Evolution plot
Mimicry.richness_values_df <- data.frame(c(Mimicry.richness.IN, Mimicry.richness.OUT)) ; names(Mimicry.richness_values_df) <-  "values"
Mimicry.richness_values_df$status <- c(rep("IN", length(Mimicry.richness.IN)), rep("OUT", length(Mimicry.richness.OUT)))
Mimicry.richness_values_df <- Mimicry.richness_values_df[order(Mimicry.richness_values_df$values, decreasing = T),]
save(Mimicry.richness_values_df, file = paste0(internal.wd,"/Maps_exploitation/Mimicry.richness_values_df.RData"))


Mimicry.richness_protec_prop <- NA
for (i in 1:100) { # Get the cumulative proportion of protected communities for each %
  N <- round(i*nrow(Mimicry.richness_values_df)/100, 0) # Number of communities to sample
  sample <- Mimicry.richness_values_df$status[1:N] # Extract the top i% communities
  Mimicry.richness_protec_prop[i] <- sum(sample=="IN")/N*100 # Compute the proportion of protected ones
}
save(Mimicry.richness_protec_prop, file = paste0(internal.wd,"/Maps_exploitation/Mimicry.richness_protec_prop.RData"))

# Plot
plot(y = Mimicry.richness_protec_prop, x = 1:100, ylim = c(0, 50), type = "l", lwd = 2, col = "red", 
     ylab = "% of protected communities", main = "Cumulative proportion of protected communities \n ranked from highest to lowest \n Mimicry Richness (Nb of mimicry rings)")
abline(h = Mimicry.richness_protec_prop[100], lwd = 2)

## Randomisation Test for X highest %
X <- 20 # 20% highest scoring communities

load(file = paste0(internal.wd,"/Maps_exploitation/Mimicry.richness_protec_prop.RData"))
load(file = paste0(internal.wd,"/Maps_exploitation/Mimicry.richness_values_df.RData"))

Mimicry.richness_20p_obs <- Mimicry.richness_protec_prop[X]

Mimicry.richness_20p_null <- NA
N_Xp <- round(X/100*nrow(Mimicry.richness_values_df),0) # Number of communities to sample to get 20% of them
for (i in 1:999) {
  sample <- sample(x = Mimicry.richness_values_df$status, size = N_Xp, replace = F) # Extract randomly N comm.
  Mimicry.richness_20p_null[i] <- sum(sample=="IN")/N_Xp*100 # Compute the proportion of protected ones
}
save(Mimicry.richness_20p_obs, Mimicry.richness_20p_null, file = paste0(internal.wd,"/Maps_exploitation/Mimicry.richness_20p_values.RData"))

# Plot
load(file = paste0(internal.wd,"/Maps_exploitation/Mimicry.richness_20p_values.RData"))
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Rando_perc_plots/20p_Rando_Mimicry.richness.jpeg"), quality = 100)
hist(c(Mimicry.richness_20p_null, Mimicry.richness_20p_obs), 30, freq = TRUE, col = "gray", main = "Distribution of the proportion of protected communities \n among the 20% communities with \n the highest Mimicry Richness (Nb of mimicry rings) \n under the null hypothesis", xlab = "% of protected communities")
arrows(Mimicry.richness_20p_obs - 0.07, 50, Mimicry.richness_20p_obs - 0.07, 5, length = 0.1, lwd = 2)
abline(v = mean(c(Mimicry.richness_20p_null, Mimicry.richness_20p_obs)), lty = 2)
abline(v = quantile(c(Mimicry.richness_20p_null, Mimicry.richness_20p_obs), 0.025), lty = 2, col = "red")
abline(v = quantile(c(Mimicry.richness_20p_null, Mimicry.richness_20p_obs), 0.975), lty = 2, col = "red")
legend(legend = c(paste0("Mean = ", round(mean(c(Mimicry.richness_20p_null, Mimicry.richness_20p_obs)), digits = 1)), 
                  paste0("CI 2.5% = ", round(quantile(c(Mimicry.richness_20p_null, Mimicry.richness_20p_obs), 0.025),1)),
                  paste0("CI 97.5% = ", round(quantile(c(Mimicry.richness_20p_null, Mimicry.richness_20p_obs), 0.975),1))), 
       x = "topright", lty = 2 , col = c("black", "red"), cex = 1, bty ="n")
legend(legend = c(paste0("Value obs = ", round(Mimicry.richness_20p_obs, 1)),
                  paste0("             p = ", 1- (ecdf(x = c(Mimicry.richness_20p_null, Mimicry.richness_20p_obs))(Mimicry.richness_20p_obs)))),
       x = "right", cex = 1, bty ="n", xjust = 1)
dev.off()

## Randomisation Test for mean value
Mimicry.richness_obs <- mean(Mimicry.richness.IN)
n.IN <- length(Mimicry.richness.IN) # Number of communities INside PAs

Mimicry.richness_values <- c(Mimicry.richness.IN, Mimicry.richness.OUT)
Mimicry.richness_null <- NA
for (i in 1:999) { # Randomize community protection status 999 times
  Mimicry.richness_null[i] <- mean(sample(x = Mimicry.richness_values, size = n.IN, replace = F)) # Extract mean values from random PAs
}
save(Mimicry.richness_obs, Mimicry.richness_null, file = paste0(internal.wd,"/Maps_exploitation/Mimicry.richness_mean_values.RData"))

# Plot
load(file = paste0(internal.wd,"/Maps_exploitation/Mimicry.richness_mean_values.RData"))
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Rando_plots/Mean_Rando_Mimicry.richness.jpeg"), quality = 100)
hist(c(Mimicry.richness_null, Mimicry.richness_obs), 30, freq = TRUE, col = "gray", main = "Distribution of the Mean Mimicry Richness \n  (Nb of mimicry rings) \n under the null hypothesis", xlab = "Mimicry Richness (Nb of mimicry rings)")
arrows(Mimicry.richness_obs + 0, 130, Mimicry.richness_obs+ 0, 15, length = 0.1, lwd = 2)
abline(v = mean(c(Mimicry.richness_null, Mimicry.richness_obs)), lty = 2)
abline(v = quantile(c(Mimicry.richness_null, Mimicry.richness_obs), 0.025), lty = 2, col = "red")
abline(v = quantile(c(Mimicry.richness_null, Mimicry.richness_obs), 0.975), lty = 2, col = "red")
legend(legend = c(paste0("Mean = ", round(mean(c(Mimicry.richness_null, Mimicry.richness_obs)),3)), 
                  paste0("CI 2.5% = ", round(quantile(c(Mimicry.richness_null, Mimicry.richness_obs), 0.025),3)),
                  paste0("CI 97.5% = ", round(quantile(c(Mimicry.richness_null, Mimicry.richness_obs), 0.975),3))), 
       x = "topright", lty = 2 , col = c("black", "red"), cex = 1, bty ="n")
legend(legend = c(paste0("Value obs = ", round(Mimicry.richness_obs, 3)),
                  paste0("                  p = ", 1-(ecdf(x = c(Mimicry.richness_null, Mimicry.richness_obs))(Mimicry.richness_obs)))),
       x = "right", cex = 1, bty ="n", xjust = 1)
dev.off()




### Mimicry Diversity (Shannon)
load(file = paste0(internal.wd,"/Com.ring.diversity.RData"))
# load(file = paste0(internal.wd,"/Com.ring.diversity.compatible.RData"))
# tot.ring.diversity <- tot.ring.diversity.compatible

# Plot
plot(tot.ring.diversity, col = pal_bl_red, main = "Shannon's Mimicry Diversity")
plot(WDPA, col = rgb(t(col2rgb(col = "black")), alpha = 0.3), add =T)

# Plot par mask
tot.ring.diversity.masked <- mask(x = tot.ring.diversity, mask = WDPA)
jpeg(filename = paste0(internal.wd,"/Maps/Indices_with_WDPA/WDPA_Mimicry_Diversity.jpeg"), quality = 100)
plot(tot.ring.diversity.masked, col = pal_bl_red, main = "Shannon's Mimicry Diversity",
     cex.axis = 1.7, cex.main = 2, axis.args=list(cex.axis=1.7))
plot(crop_mask_shp, add = T)
dev.off()

# Extraire les données du raster dans les buffers IN/OUT WDPA
Mimicry.Div.IN <- na.omit(unlist(extract(tot.ring.diversity, WDPA)))
Mimicry.Div.OUT <- na.omit(unlist(extract(tot.ring.diversity, WDPA_antimask_shp)))
save(Mimicry.Div.IN, Mimicry.Div.OUT, file = paste0(internal.wd, "/Maps_exploitation/Mimicry.Div.IN.OUT.RData")) 

load(file = paste0(internal.wd, "/Maps_exploitation/Mimicry.Div.IN.OUT.RData")) 
# Faire un sampling aléatoire pour obtenir des données indépendantes spatialement ? 
# Approche bourrine et complexe = SEVF avec nieghbor définit par l'appartenance à une même NP (par rapport à l'ID)
sampled.Mimicry.Div.IN <- sample(x = Mimicry.Div.IN, size = 1000, replace = F) 
sampled.Mimicry.Div.OUT <- sample(x = Mimicry.Div.OUT, size = 1000, replace = F) 

hist(sampled.Mimicry.Div.IN)
hist(sampled.Mimicry.Div.OUT)

shapiro.test(sampled.Mimicry.Div.IN)
shapiro.test(sampled.Mimicry.Div.OUT)
var.test(sampled.Mimicry.Div.IN, sampled.Mimicry.Div.OUT, alt="two.sided")

wilcox.test(x = sampled.Mimicry.Div.IN, y = sampled.Mimicry.Div.OUT, alternative = "two.sided", paired = F)

# Boxplot
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Boxplots/Boxplot_Mimicry_Div.jpeg"), quality =100)
boxplot(type = "n", x = cbind(Mimicry.Div.IN, Mimicry.Div.OUT), col = c("limegreen", "grey"), ylab = "Shannon's Mimicry Diversity Index", main = "Shannon's Mimicry Diversity \n INside or OUTside of Protected Areas", notch = F, las = 1, names = c("IN","OUT")) 
abline(h=seq(0,5,0.25),col="grey80", lty="dotted",lwd = 0.4)
abline(v=seq(0,3, 0.25),col="grey80", lty="dotted",lwd = 0.4)
boxplot(add = T , x = cbind(Mimicry.Div.IN, Mimicry.Div.OUT), col = c("limegreen", "grey"), notch = F, las = 1, names = c("IN","OUT")) 
# legend(x = "topleft", legend = c("Wilcox Test", "p = 0.034"))
dev.off()

## Evolution plot
Mimicry.Div_values_df <- data.frame(c(Mimicry.Div.IN, Mimicry.Div.OUT)) ; names(Mimicry.Div_values_df) <-  "values"
Mimicry.Div_values_df$status <- c(rep("IN", length(Mimicry.Div.IN)), rep("OUT", length(Mimicry.Div.OUT)))
Mimicry.Div_values_df <- Mimicry.Div_values_df[order(Mimicry.Div_values_df$values, decreasing = T),]
save(Mimicry.Div_values_df, file = paste0(internal.wd,"/Maps_exploitation/Mimicry.Div_values_df.RData"))

Mimicry.Div_protec_prop <- NA
for (i in 1:100) { # Get the cumulative proportion of protected communities for each %
  N <- round(i*nrow(Mimicry.Div_values_df)/100, 0) # Number of communities to sample
  sample <- Mimicry.Div_values_df$status[1:N] # Extract the top i% communities
  Mimicry.Div_protec_prop[i] <- sum(sample=="IN")/N*100 # Compute the proportion of protected ones
}
save(Mimicry.Div_protec_prop, file = paste0(internal.wd,"/Maps_exploitation/Mimicry.Div_protec_prop.RData"))

# Plot
plot(y = Mimicry.Div_protec_prop, x = 1:100, ylim = c(0, 50), type = "l", lwd = 2, col = "red", 
     ylab = "% of protected communities", main = "Cumulative proportion of protected communities \n ranked from highest to lowest \n Shannon's Mimicry Diversity")
abline(h = Mimicry.Div_protec_prop[100], lwd = 2)

## Randomisation Test for X highest %
X <- 20 # 20% highest scoring communities

load(file = paste0(internal.wd,"/Maps_exploitation/Mimicry.Div_protec_prop.RData"))
load(file = paste0(internal.wd,"/Maps_exploitation/Mimicry.Div_values_df.RData"))

Mimicry.Div_20p_obs <- Mimicry.Div_protec_prop[X]

Mimicry.Div_20p_null <- NA
N_Xp <- round(X/100*nrow(Mimicry.Div_values_df),0) # Number of communities to sample to get 20% of them
for (i in 1:999) {
  sample <- sample(x = Mimicry.Div_values_df$status, size = N_Xp, replace = F) # Extract randomly N comm.
  Mimicry.Div_20p_null[i] <- sum(sample=="IN")/N_Xp*100 # Compute the proportion of protected ones
}
save(Mimicry.Div_20p_obs, Mimicry.Div_20p_null, file = paste0(internal.wd,"/Maps_exploitation/Mimicry.Div_20p_values.RData"))

# Plot
load(file = paste0(internal.wd,"/Maps_exploitation/Mimicry.Div_20p_values.RData"))
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Rando_perc_plots/20p_Rando_Mimicry.Div.jpeg"), quality = 100)
hist(c(Mimicry.Div_20p_null, Mimicry.Div_20p_obs), 30, freq = TRUE, col = "gray", main = "Distribution of the proportion of protected communities \n among the 20% communities with \n the highest Shannon's Mimicry Diversity \n under the null hypothesis", xlab = "% of protected communities")
arrows(Mimicry.Div_20p_obs - 0.05, 50, Mimicry.Div_20p_obs - 0.05, 5, length = 0.1, lwd = 2)
abline(v = mean(c(Mimicry.Div_20p_null, Mimicry.Div_20p_obs)), lty = 2)
abline(v = quantile(c(Mimicry.Div_20p_null, Mimicry.Div_20p_obs), 0.025), lty = 2, col = "red")
abline(v = quantile(c(Mimicry.Div_20p_null, Mimicry.Div_20p_obs), 0.975), lty = 2, col = "red")
legend(legend = c(paste0("Mean = ", round(mean(c(Mimicry.Div_20p_null, Mimicry.Div_20p_obs)), digits = 1)),
                  paste0("CI 2.5% = ", round(quantile(c(Mimicry.Div_20p_null, Mimicry.Div_20p_obs), 0.025),1)),
                  paste0("CI 97.5% = ", round(quantile(c(Mimicry.Div_20p_null, Mimicry.Div_20p_obs), 0.975),1))), 
       x = "topright", lty = 2 , col = c("black", "red"), cex = 1, bty ="n")
legend(legend = c(paste0("Value obs = ", round(Mimicry.Div_20p_obs, 1)),
                  paste0("             p = ", 1- (ecdf(x = c(Mimicry.Div_20p_null, Mimicry.Div_20p_obs))(Mimicry.Div_20p_obs)))),
       x = "right", cex = 1, bty ="n", xjust = 1)
dev.off()

## Randomisation Test for mean value
Mimicry.Div_obs <- mean(Mimicry.Div.IN)
n.IN <- length(Mimicry.Div.IN) # Number of communities INside PAs

Mimicry.Div_values <- c(Mimicry.Div.IN, Mimicry.Div.OUT)
Mimicry.Div_null <- NA
for (i in 1:999) { # Randomize community protection status 999 times
  Mimicry.Div_null[i] <- mean(sample(x = Mimicry.Div_values, size = n.IN, replace = F)) # Extract mean values from random PAs
}
save(Mimicry.Div_obs, Mimicry.Div_null, file = paste0(internal.wd,"/Maps_exploitation/Mimicry.Div_mean_values.RData"))

# Plot
load(file = paste0(internal.wd,"/Maps_exploitation/Mimicry.Div_mean_values.RData"))
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Rando_plots/Mean_Rando_Mimicry.Div.jpeg"), quality = 100)
hist(c(Mimicry.Div_null, Mimicry.Div_obs), 30, freq = TRUE, col = "gray", main = "Distribution of the Mean Shannon's Mimicry Diversity \n under the null hypothesis", xlab = "Shannon's Mimicry Diversity Index")
arrows(Mimicry.Div_obs + 0.001, 130, Mimicry.Div_obs + 0.001, 15, length = 0.1, lwd = 2)
abline(v = mean(c(Mimicry.Div_null, Mimicry.Div_obs)), lty = 2)
abline(v = quantile(c(Mimicry.Div_null, Mimicry.Div_obs), 0.025), lty = 2, col = "red")
abline(v = quantile(c(Mimicry.Div_null, Mimicry.Div_obs), 0.975), lty = 2, col = "red")
legend(legend = c(paste0("Mean = ", round(mean(c(Mimicry.Div_null, Mimicry.Div_obs)),3)),
                  paste0("CI 2.5% = ", round(quantile(c(Mimicry.Div_null, Mimicry.Div_obs), 0.025),3)),
                  paste0("CI 97.5% = ", round(quantile(c(Mimicry.Div_null, Mimicry.Div_obs), 0.975),3))), 
       x = "topright", lty = 2 , col = c("black", "red"), cex = 1, bty ="n")
legend(legend = c(paste0("Value obs = ", round(Mimicry.Div_obs, 3)),
                  paste0("                  p = ", 1-(ecdf(x = c(Mimicry.Div_null, Mimicry.Div_obs))(Mimicry.Div_obs)))),
       x = "right", cex = 1, bty ="n", xjust = 1)
dev.off()


### Mimicry Diversity (Jost transfo)
load(file = paste0(internal.wd,"/Com.ring.diversity.RData"))
# load(file = paste0(internal.wd,"/Com.ring.diversity.compatible.RData"))
# tot.ring.diversity <- tot.ring.diversity.compatible

# Plot
plot(exp(tot.ring.diversity), col = pal_bl_red, main = "Jost's transformation of Shannon's Mimicry Diversity \n (Jost's Effective Mimcry Richness)")
plot(WDPA, col = rgb(t(col2rgb(col = "black")), alpha = 0.3), add =T)

# Plot par mask
tot.ring.diversity.masked_Jost <- mask(x = exp(tot.ring.diversity), mask = WDPA)
jpeg(filename = paste0(internal.wd,"/Maps/Indices_with_WDPA/WDPA_Mimicry_Diversity_Jost.jpeg"), quality = 100)
plot(tot.ring.diversity.masked_Jost, col = pal_bl_red, main = "Mimicry Diversity \n (Jost's Effective Mimicry Richness)",
     cex.axis = 1.7, cex.main = 2, axis.args=list(cex.axis=1.7))
plot(crop_mask_shp, add = T)
dev.off()

# Extraire les données du raster dans les buffers IN/OUT WDPA
Mimicry.Div.Jost.IN <- na.omit(unlist(extract(exp(tot.ring.diversity), WDPA)))
Mimicry.Div.Jost.OUT <- na.omit(unlist(extract(exp(tot.ring.diversity), WDPA_antimask_shp)))
save(Mimicry.Div.Jost.IN, Mimicry.Div.Jost.OUT, file = paste0(internal.wd, "/Maps_exploitation/Mimicry.Div.Jost.IN.OUT.RData")) 

load(file = paste0(internal.wd, "/Maps_exploitation/Mimicry.Div.Jost.IN.OUT.RData")) 
# Faire un sampling aléatoire pour obtenir des données indépendantes spatialement ? 
# Approche bourrine et complexe = SEVF avec nieghbor définit par l'appartenance à une même NP (par rapport à l'ID)
sampled.Mimicry.Div.Jost.IN <- sample(x = Mimicry.Div.Jost.IN, size = 1000, replace = F) 
sampled.Mimicry.Div.Jost.OUT <- sample(x = Mimicry.Div.Jost.OUT, size = 1000, replace = F) 

hist(sampled.Mimicry.Div.Jost.IN)
hist(sampled.Mimicry.Div.Jost.OUT)

shapiro.test(sampled.Mimicry.Div.Jost.IN)
shapiro.test(sampled.Mimicry.Div.Jost.OUT)
var.test(sampled.Mimicry.Div.Jost.IN, sampled.Mimicry.Div.Jost.OUT, alt="two.sided")

wilcox.test(x = sampled.Mimicry.Div.Jost.IN, y = sampled.Mimicry.Div.Jost.OUT, alternative = "two.sided", paired = F)

# Boxplot
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Boxplots/Boxplot_Mimicry_Div_Jost.jpeg"), quality =100)
boxplot(type = "n", x = cbind(Mimicry.Div.Jost.IN, Mimicry.Div.Jost.OUT), col = c("limegreen", "grey"), ylab = "Jost's Effective Mimicry Richness", main = "Jost's transformation of \n Shannon's Mimicry Diversity \n INside or OUTside of Protected Areas", notch = F, las = 1, names = c("IN","OUT")) 
abline(h=seq(0,25, 2),col="grey80", lty="dotted",lwd = 0.4)
abline(v=seq(0,3, 0.25),col="grey80", lty="dotted",lwd = 0.4)
boxplot(add = T , x = cbind(Mimicry.Div.Jost.IN, Mimicry.Div.Jost.OUT), col = c("limegreen", "grey"), notch = F, las = 1, names = c("IN","OUT")) 
# legend(x = "topleft", legend = c("Wilcox Test", "p = 0.034"))
dev.off()

## Evolution plot
Mimicry.Div.Jost_values_df <- data.frame(c(Mimicry.Div.Jost.IN, Mimicry.Div.Jost.OUT)) ; names(Mimicry.Div.Jost_values_df) <-  "values"
Mimicry.Div.Jost_values_df$status <- c(rep("IN", length(Mimicry.Div.Jost.IN)), rep("OUT", length(Mimicry.Div.Jost.OUT)))
Mimicry.Div.Jost_values_df <- Mimicry.Div.Jost_values_df[order(Mimicry.Div.Jost_values_df$values, decreasing = T),]

Mimicry.Div.Jost_protec_prop <- NA
for (i in 1:100) { # Get the cumulative proportion of protected communities for each %
  N <- round(i*nrow(Mimicry.Div.Jost_values_df)/100, 0) # Number of communities to sample
  sample <- Mimicry.Div.Jost_values_df$status[1:N] # Extract the top i% communities
  Mimicry.Div.Jost_protec_prop[i] <- sum(sample=="IN")/N*100 # Compute the proportion of protected ones
}
save(Mimicry.Div.Jost_protec_prop, file = paste0(internal.wd,"/Maps_exploitation/Mimicry.Div.Jost_protec_prop.RData"))

# Plot
plot(y = Mimicry.Div.Jost_protec_prop, x = 1:100, ylim = c(0, 50), type = "l", lwd = 2, col = "red", 
     ylab = "% of protected communities", main = "Cumulative proportion of protected communities \n ranked from highest to lowest \n Jost's Effective Mimicry Richness")
abline(h = Mimicry.Div.Jost_protec_prop[100], lwd = 2)

## Randomisation Test for mean value
Mimicry.Div.Jost_obs <- mean(Mimicry.Div.Jost.IN)
n.IN <- length(Mimicry.Div.Jost.IN) # Number of communities INside PAs

Mimicry.Div.Jost_values <- c(Mimicry.Div.Jost.IN, Mimicry.Div.Jost.OUT)
Mimicry.Div.Jost_null <- NA
for (i in 1:999) { # Randomize community protection status 999 times
  Mimicry.Div.Jost_null[i] <- mean(sample(x = Mimicry.Div.Jost_values, size = n.IN, replace = F)) # Extract mean values from random PAs
}
save(Mimicry.Div.Jost_obs, Mimicry.Div.Jost_null, file = paste0(internal.wd,"/Maps_exploitation/Mimicry.Div.Jost_mean_values.RData"))

# Plot
load(file = paste0(internal.wd,"/Maps_exploitation/Mimicry.Div.Jost_mean_values.RData"))
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Rando_plots/Mean_Rando_Mimicry.Div.Jost.jpeg"), quality = 100)
hist(c(Mimicry.Div.Jost_null, Mimicry.Div.Jost_obs), 30, freq = TRUE, col = "gray", main = "Distribution of the Mean \n Jost's Effective Mimicry Richness \n under the null hypothesis", xlab = "Jost's Effective Mimicry Richness")
arrows(Mimicry.Div.Jost_obs - 0.005, 80, Mimicry.Div.Jost_obs - 0.005, 15, length = 0.1, lwd = 2)
abline(v = mean(c(Mimicry.Div.Jost_null, Mimicry.Div.Jost_obs)), lty = 2)
abline(v = quantile(c(Mimicry.Div.Jost_null, Mimicry.Div.Jost_obs), 0.025), lty = 2, col = "red")
abline(v = quantile(c(Mimicry.Div.Jost_null, Mimicry.Div.Jost_obs), 0.975), lty = 2, col = "red")
legend(legend = c(paste0("Mean = ", round(mean(c(Mimicry.Div.Jost_null, Mimicry.Div.Jost_obs)),3)), 
                  paste0("CI 2.5% = ", round(quantile(c(Mimicry.Div.Jost_null, Mimicry.Div.Jost_obs), 0.025),3)),
                  paste0("CI 97.5% = ", round(quantile(c(Mimicry.Div.Jost_null, Mimicry.Div.Jost_obs), 0.975),3))), 
       x = "topright", lty = 2 , col = c("black", "red"), cex = 1, bty ="n")
legend(legend = c(paste0("Value obs = ", round(Mimicry.Div.Jost_obs, 3)),
                  paste0("                  p = ", 1-(ecdf(x = c(Mimicry.Div.Jost_null, Mimicry.Div.Jost_obs))(Mimicry.Div.Jost_obs)))),
       x = "right", cex = 1, bty ="n", xjust = 1)
dev.off()





### Mean Mimicry Ring Rarity (Mimicry Mean Weighted Richness)
load(file = paste0(internal.wd,"/Com.mimicry.mean.rarity.RData"))

# Plot par mask
mimicry.mean.rarity.masked <- mask(x = mimicry.mean.rarity, mask = WDPA)
jpeg(filename = paste0(internal.wd,"/Maps/Indices_with_WDPA/WDPA_Mean_Mimicry_Rarity.jpeg"), quality =100)
plot(mimicry.mean.rarity.masked, col = pal_bl_red, main = "Mean Mimicry Rarity",
     cex.axis = 1.7, cex.main = 2, axis.args=list(cex.axis=1.7))
plot(crop_mask_shp, add = T)
dev.off()

# Extraire les données du raster dans les buffers IN/OUT WDPA
mimicry.mean.rarity.IN <- na.omit(unlist(extract(mimicry.mean.rarity, WDPA)))
mimicry.mean.rarity.OUT <- na.omit(unlist(extract(mimicry.mean.rarity, WDPA_antimask_shp)))
save(mimicry.mean.rarity.IN, mimicry.mean.rarity.OUT, file = paste0(internal.wd, "/Maps_exploitation/mimicry.mean.rarity.IN.OUT.RData")) 

load(file = paste0(internal.wd, "/Maps_exploitation/mimicry.mean.rarity.IN.OUT.RData")) 
# Faire un sampling aléatoire pour obtenir des données indépendantes spatialement ? 
# Approche bourrine et complexe = SEVF avec nieghbor définit par l'appartenance à une même NP (par rapport à l'ID)
sampled.mimicry.mean.rarity.IN <- sample(x = mimicry.mean.rarity.IN, size = 1000, replace = F) 
sampled.mimicry.mean.rarity.OUT <- sample(x = mimicry.mean.rarity.OUT, size = 1000, replace = F) 

hist(sampled.mimicry.mean.rarity.IN)
hist(sampled.mimicry.mean.rarity.OUT)

shapiro.test(sampled.mimicry.mean.rarity.IN)
shapiro.test(sampled.mimicry.mean.rarity.OUT)
var.test(sampled.mimicry.mean.rarity.IN, sampled.mimicry.mean.rarity.OUT, alt="two.sided")

wilcox.test(x = sampled.mimicry.mean.rarity.IN, y = sampled.mimicry.mean.rarity.OUT, alternative = "two.sided", paired = F)

# Boxplot
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Boxplots/Boxplot_Mean_Mimicry_Rarity.jpeg"), quality =100)
boxplot(type = "n", x = cbind(mimicry.mean.rarity.IN, mimicry.mean.rarity.OUT), col = c("limegreen", "grey"), notch = F, las = 1, ylab = "Mean Mimicry Ring Rarity", main = "Mean Mimicry Ring Rarity \n INside or OUTside of Protected Areas", names = c("IN","OUT")) 
abline(h=seq(0, 1, 0.1),col="grey80", lty="dotted",lwd = 0.4)
abline(v=seq(0,3, 0.25),col="grey80", lty="dotted",lwd = 0.4)
boxplot(add = T , x = cbind(mimicry.mean.rarity.IN, mimicry.mean.rarity.OUT), col = c("limegreen", "grey"), notch = F, las = 1, names = c("IN","OUT")) 
# legend(x = "topleft", legend = c("Wilcox Test", "p < 0.001"))
dev.off()

## Evolution plot
mimicry.mean.rarity_values_df <- data.frame(c(mimicry.mean.rarity.IN, mimicry.mean.rarity.OUT)) ; names(mimicry.mean.rarity_values_df) <-  "values"
mimicry.mean.rarity_values_df$status <- c(rep("IN", length(mimicry.mean.rarity.IN)), rep("OUT", length(mimicry.mean.rarity.OUT)))
mimicry.mean.rarity_values_df <- mimicry.mean.rarity_values_df[order(mimicry.mean.rarity_values_df$values, decreasing = T),]
save(mimicry.mean.rarity_values_df, file = paste0(internal.wd,"/Maps_exploitation/mimicry.mean.rarity_values_df.RData"))

mimicry.mean.rarity_protec_prop <- NA
for (i in 1:100) { # Get the cumulative proportion of protected communities for each %
  N <- round(i*nrow(mimicry.mean.rarity_values_df)/100, 0) # Number of communities to sample
  sample <- mimicry.mean.rarity_values_df$status[1:N] # Extract the top i% communities
  mimicry.mean.rarity_protec_prop[i] <- sum(sample=="IN")/N*100 # Compute the proportion of protected ones
}
save(mimicry.mean.rarity_protec_prop, file = paste0(internal.wd,"/Maps_exploitation/mimicry.mean.rarity_protec_prop.RData"))

# Plot
plot(y = mimicry.mean.rarity_protec_prop, x = 1:100, ylim = c(0, 50), type = "l", lwd = 2, col = "red", 
     ylab = "% of protected communities", main = "Cumulative proportion of protected communities \n ranked from highest to lowest \n Mean Mimicry Ring Rarity")
abline(h = mimicry.mean.rarity_protec_prop[100], lwd = 2)

## Randomisation Test for X highest %
X <- 20 # 20% highest scoring communities

load(file = paste0(internal.wd,"/Maps_exploitation/mimicry.mean.rarity_protec_prop.RData"))
load(file = paste0(internal.wd,"/Maps_exploitation/mimicry.mean.rarity_values_df.RData"))

mimicry.mean.rarity_20p_obs <- mimicry.mean.rarity_protec_prop[X]

mimicry.mean.rarity_20p_null <- NA
N_Xp <- round(X/100*nrow(mimicry.mean.rarity_values_df),0) # Number of communities to sample to get 20% of them
for (i in 1:999) {
  sample <- sample(x = mimicry.mean.rarity_values_df$status, size = N_Xp, replace = F) # Extract randomly N comm.
  mimicry.mean.rarity_20p_null[i] <- sum(sample=="IN")/N_Xp*100 # Compute the proportion of protected ones
}
save(mimicry.mean.rarity_20p_obs, mimicry.mean.rarity_20p_null, file = paste0(internal.wd,"/Maps_exploitation/mimicry.mean.rarity_20p_values.RData"))

# Plot
load(file = paste0(internal.wd,"/Maps_exploitation/mimicry.mean.rarity_20p_values.RData"))
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Rando_perc_plots/20p_Rando_mimicry.mean.rarity.jpeg"), quality = 100)
hist(c(mimicry.mean.rarity_20p_null, mimicry.mean.rarity_20p_obs), 30, freq = TRUE, col = "gray", main = "Distribution of the proportion of protected communities \n among the 20% communities with \n the highest Mean Mimicry Ring Rarity \n under the null hypothesis", xlab = "% of protected communities")
arrows(mimicry.mean.rarity_20p_obs + 0.05, 50, mimicry.mean.rarity_20p_obs + 0.05, 5, length = 0.1, lwd = 2)
abline(v = mean(c(mimicry.mean.rarity_20p_null, mimicry.mean.rarity_20p_obs)), lty = 2)
abline(v = quantile(c(mimicry.mean.rarity_20p_null, mimicry.mean.rarity_20p_obs), 0.025), lty = 2, col = "red")
abline(v = quantile(c(mimicry.mean.rarity_20p_null, mimicry.mean.rarity_20p_obs), 0.975), lty = 2, col = "red")
legend(legend = c(paste0("Mean = ", round(mean(c(mimicry.mean.rarity_20p_null, mimicry.mean.rarity_20p_obs)), digits = 1)), 
                  paste0("CI 2.5% = ", round(quantile(c(mimicry.mean.rarity_20p_null, mimicry.mean.rarity_20p_obs), 0.025),1)),
                  paste0("CI 97.5% = ", round(quantile(c(mimicry.mean.rarity_20p_null, mimicry.mean.rarity_20p_obs), 0.975),1))), 
       x = "topright", lty = 2 , col = c("black", "red"), cex = 1, bty ="n")
legend(legend = c(paste0("Value obs = ", round(mimicry.mean.rarity_20p_obs, 1)),
                  paste0("     p = ", (ecdf(x = c(mimicry.mean.rarity_20p_null, mimicry.mean.rarity_20p_obs))(mimicry.mean.rarity_20p_obs)))),
       x = "left", cex = 1, bty ="n", xjust = 1)
dev.off()

## Randomisation Test for mean value
mimicry.mean.rarity_obs <- mean(mimicry.mean.rarity.IN)
n.IN <- length(mimicry.mean.rarity.IN) # Number of communities INside PAs

mimicry.mean.rarity_values <- c(mimicry.mean.rarity.IN, mimicry.mean.rarity.OUT)
mimicry.mean.rarity_null <- NA
for (i in 1:999) { # Randomize community protection status 999 times
  mimicry.mean.rarity_null[i] <- mean(sample(x = mimicry.mean.rarity_values, size = n.IN, replace = F)) # Extract mean values from random PAs
}
save(mimicry.mean.rarity_obs, mimicry.mean.rarity_null, file = paste0(internal.wd,"/Maps_exploitation/mimicry.mean.rarity_mean_values.RData"))

# Plot
load(file = paste0(internal.wd,"/Maps_exploitation/mimicry.mean.rarity_mean_values.RData"))
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Rando_plots/Mean_Rando_mimicry.mean.rarity.jpeg"), quality = 100)
hist(c(mimicry.mean.rarity_null, mimicry.mean.rarity_obs), 30, freq = TRUE, col = "gray", main = "Distribution of the Mean \n Average Mimicry Ring Rarity \n under the null hypothesis", xlab = "Mean Mimicry Ring Rarity")
arrows(mimicry.mean.rarity_obs - 0.0003, 60, mimicry.mean.rarity_obs - 0.0003, 15, length = 0.1, lwd = 2)
abline(v = mean(c(mimicry.mean.rarity_null, mimicry.mean.rarity_obs)), lty = 2)
abline(v = quantile(c(mimicry.mean.rarity_null, mimicry.mean.rarity_obs), 0.025), lty = 2, col = "red")
abline(v = quantile(c(mimicry.mean.rarity_null, mimicry.mean.rarity_obs), 0.975), lty = 2, col = "red")
legend(legend = c(paste0("Mean = ", round(mean(c(mimicry.mean.rarity_null, mimicry.mean.rarity_obs)),3)), 
                  paste0("CI 2.5% = ", round(quantile(c(mimicry.mean.rarity_null, mimicry.mean.rarity_obs), 0.025),3)),
                  paste0("CI 97.5% = ", round(quantile(c(mimicry.mean.rarity_null, mimicry.mean.rarity_obs), 0.975),3))), 
       x = "topright", lty = 2 , col = c("black", "red"), cex = 1, bty ="n")
legend(legend = c(paste0("Value obs = ", round(mimicry.mean.rarity_obs, 3)),
                  paste0("                  p = ", 1-(ecdf(x = c(mimicry.mean.rarity_null, mimicry.mean.rarity_obs))(mimicry.mean.rarity_obs)))),
       x = "right", cex = 1, bty ="n", xjust = 1)
dev.off()




### Vulnerability
load(file = paste0(internal.wd,"/Com.vulnerability.RData"))

# Plot
plot(vulnerability, col = pal_bl_red, main = "Community Vulnerability")
plot(WDPA, col = rgb(t(col2rgb(col = "black")), alpha = 0.3), add =T)

# Plot par mask
vulnerability.masked <- mask(x = vulnerability, mask = WDPA)
jpeg(filename = paste0(internal.wd,"/Maps/Indices_with_WDPA/WDPA_Vulnerability.jpeg"), quality =100)
plot(vulnerability.masked, col = pal_bl_red, main = "Community Vulnerability",
     cex.axis = 1.7, cex.main = 2, axis.args=list(cex.axis=1.7))
plot(crop_mask_shp, add = T)
dev.off()

# Extraire les données du raster dans les buffers IN/OUT WDPA
Vulnerability.IN <- na.omit(unlist(extract(vulnerability, WDPA)))
Vulnerability.OUT <- na.omit(unlist(extract(vulnerability, WDPA_antimask_shp)))
save(Vulnerability.IN, Vulnerability.OUT, file = paste0(internal.wd, "/Maps_exploitation/Vulnerability.IN.OUT.RData")) 

load(file = paste0(internal.wd, "/Maps_exploitation/Vulnerability.IN.OUT.RData")) 
# Faire un sampling aléatoire pour obtenir des données indépendantes spatialement ? 
# Approche bourrine et complexe = SEVF avec nieghbor définit par l'appartenance à une même NP (par rapport à l'ID)
sampled.Vulnerability.IN <- sample(x = Vulnerability.IN, size = 1000, replace = F) 
sampled.Vulnerability.OUT <- sample(x = Vulnerability.OUT, size = 1000, replace = F) 

hist(sampled.Vulnerability.IN)
hist(sampled.Vulnerability.OUT)

shapiro.test(sampled.Vulnerability.IN)
shapiro.test(sampled.Vulnerability.OUT)
var.test(sampled.Vulnerability.IN, sampled.Vulnerability.OUT, alt="two.sided")

wilcox.test(x = sampled.Vulnerability.IN, y = sampled.Vulnerability.OUT, alternative = "two.sided", paired = F)

# Boxplot
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Boxplots/Boxplot_Vulnerability.jpeg"), quality =100)
boxplot(type = "n", x = cbind(Vulnerability.IN, Vulnerability.OUT), col = c("limegreen", "grey"), notch = F, ylab = "Mean Mimicry Ring Vulnerability", main = "Community Vulnerability \n INside or OUTside of Protected Areas" ,las = 1, names = c("IN","OUT")) 
abline(h=seq(0, 1,0.1),col="grey80", lty="dotted",lwd = 0.4)
abline(v=seq(0,3, 0.25),col="grey80", lty="dotted",lwd = 0.4)
boxplot(add = T , x = cbind(Vulnerability.IN, Vulnerability.OUT), col = c("limegreen", "grey"), notch = F, las = 1, names = c("IN","OUT")) 
# legend(x = "topleft", legend = c("Wilcox Test", "p = 0.009"))
dev.off()

## Evolution plot
Vulnerability_values_df <- data.frame(c(Vulnerability.IN, Vulnerability.OUT)) ; names(Vulnerability_values_df) <-  "values"
Vulnerability_values_df$status <- c(rep("IN", length(Vulnerability.IN)), rep("OUT", length(Vulnerability.OUT)))
Vulnerability_values_df <- Vulnerability_values_df[order(Vulnerability_values_df$values, decreasing = T),]
save(Vulnerability_values_df, file = paste0(internal.wd,"/Maps_exploitation/Vulnerability_values_df.RData"))

Vulnerability_protec_prop <- NA
for (i in 1:100) { # Get the cumulative proportion of protected communities for each %
  N <- round(i*nrow(Vulnerability_values_df)/100, 0) # Number of communities to sample
  sample <- Vulnerability_values_df$status[1:N] # Extract the top i% communities
  Vulnerability_protec_prop[i] <- sum(sample=="IN")/N*100 # Compute the proportion of protected ones
}
save(Vulnerability_protec_prop, file = paste0(internal.wd,"/Maps_exploitation/Vulnerability_protec_prop.RData"))

# Plot
plot(y = Vulnerability_protec_prop, x = 1:100, ylim = c(0, 100), type = "l", lwd = 2, col = "red", 
     ylab = "% of protected communities", main = "Cumulative proportion of protected communities \n ranked from highest to lowest \n Community Vulnerability")
abline(h = Vulnerability_protec_prop[100], lwd = 2)

## Randomisation Test for X highest %
X <- 20 # 20% highest scoring communities

load(file = paste0(internal.wd,"/Maps_exploitation/Vulnerability_protec_prop.RData"))
load(file = paste0(internal.wd,"/Maps_exploitation/Vulnerability_values_df.RData"))

Vulnerability_20p_obs <- Vulnerability_protec_prop[X]

Vulnerability_20p_null <- NA
N_Xp <- round(X/100*nrow(Vulnerability_values_df),0) # Number of communities to sample to get 20% of them
for (i in 1:999) {
  sample <- sample(x = Vulnerability_values_df$status, size = N_Xp, replace = F) # Extract randomly N comm.
  Vulnerability_20p_null[i] <- sum(sample=="IN")/N_Xp*100 # Compute the proportion of protected ones
}
save(Vulnerability_20p_obs, Vulnerability_20p_null, file = paste0(internal.wd,"/Maps_exploitation/Vulnerability_20p_values.RData"))

# Plot
load(file = paste0(internal.wd,"/Maps_exploitation/Vulnerability_20p_values.RData"))
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Rando_perc_plots/20p_Rando_Vulnerability.jpeg"), quality = 100)
hist(c(Vulnerability_20p_null, Vulnerability_20p_obs), 30, freq = TRUE, col = "gray", main = "Distribution of the proportion of protected communities \n among the 20% communities with \n the highest Community Vulnerability \n under the null hypothesis", xlab = "% of protected communities")
arrows(Vulnerability_20p_obs - 0.09, 100, Vulnerability_20p_obs - 0.09, 5, length = 0.1, lwd = 2)
abline(v = mean(c(Vulnerability_20p_null, Vulnerability_20p_obs)), lty = 2)
abline(v = quantile(c(Vulnerability_20p_null, Vulnerability_20p_obs), 0.025), lty = 2, col = "red")
abline(v = quantile(c(Vulnerability_20p_null, Vulnerability_20p_obs), 0.975), lty = 2, col = "red")
legend(legend = c(paste0("Mean = ", round(mean(c(Vulnerability_20p_null, Vulnerability_20p_obs)), digits = 1)), 
                  paste0("CI 2.5% = ", round(quantile(c(Vulnerability_20p_null, Vulnerability_20p_obs), 0.025),1)),
                  paste0("CI 97.5% = ", round(quantile(c(Vulnerability_20p_null, Vulnerability_20p_obs), 0.975),1))), 
       x = "topleft", lty = 2 , col = c("black", "red"), cex = 1, bty ="n")
legend(legend = c(paste0("Value obs = ", round(Vulnerability_20p_obs, 1)),
                  paste0("      p = ", (ecdf(x = c(Vulnerability_20p_null, Vulnerability_20p_obs))(Vulnerability_20p_obs)))),
       x = "left", cex = 1, bty ="n", xjust = 1)
dev.off()

## Randomisation Test for mean value
Vulnerability_obs <- mean(Vulnerability.IN)
n.IN <- length(Vulnerability.IN) # Number of communities INside PAs

Vulnerability_values <- c(Vulnerability.IN, Vulnerability.OUT)
Vulnerability_null <- NA
for (i in 1:999) { # Randomize community protection status 999 times
  Vulnerability_null[i] <- mean(sample(x = Vulnerability_values, size = n.IN, replace = F)) # Extract mean values from random PAs
}
save(Vulnerability_obs, Vulnerability_null, file = paste0(internal.wd,"/Maps_exploitation/Vulnerability_mean_values.RData"))

# Plot
load(file = paste0(internal.wd,"/Maps_exploitation/Vulnerability_mean_values.RData"))
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Rando_plots/Mean_Rando_Vulnerability.jpeg"), quality = 100)
hist(c(Vulnerability_null, Vulnerability_obs), 30, freq = TRUE, col = "gray", main = "Distribution of the Mean \n Community Vulnerability \n under the null hypothesis", xlab = "Mean Mimicry Ring Vulnerability")
arrows(Vulnerability_obs + 0.0005, 100, Vulnerability_obs + 0.0005, 15, length = 0.1, lwd = 2)
abline(v = mean(c(Vulnerability_null, Vulnerability_obs)), lty = 2)
abline(v = quantile(c(Vulnerability_null, Vulnerability_obs), 0.025), lty = 2, col = "red")
abline(v = quantile(c(Vulnerability_null, Vulnerability_obs), 0.975), lty = 2, col = "red")
legend(legend = c(paste0("Mean = ", round(mean(c(Vulnerability_null, Vulnerability_obs)),3)), 
                  paste0("CI 2.5% = ", round(quantile(c(Vulnerability_null, Vulnerability_obs), 0.025),3)),
                  paste0("CI 97.5% = ", round(quantile(c(Vulnerability_null, Vulnerability_obs), 0.975),3))), 
       x = "topleft", lty = 2 , col = c("black", "red"), cex = 1, bty ="n")
legend(legend = c(paste0("Value obs = ", round(Vulnerability_obs, 3)),
                  paste0("          p = ", (ecdf(x = c(Vulnerability_null, Vulnerability_obs))(Vulnerability_obs)))),
       x = "left", cex = 1, bty ="n", xjust = 1)
dev.off()


##### Global % Evolution Plot

# Load all the lines data
load(file = paste0(internal.wd,"/Maps_exploitation/sp.richness_protec_prop.RData"))
load(file = paste0(internal.wd,"/Maps_exploitation/sp.diversity_protec_prop.RData"))
load(file = paste0(internal.wd,"/Maps_exploitation/mean.sp.rarity_protec_prop.RData"))

load(file = paste0(internal.wd,"/Maps_exploitation/Faith.PD_protec_prop.RData"))
load(file = paste0(internal.wd,"/Maps_exploitation/FP_protec_prop.RData"))
load(file = paste0(internal.wd,"/Maps_exploitation/MPD_protec_prop.RData"))

load(file = paste0(internal.wd,"/Maps_exploitation/mimicry.richness_protec_prop.RData"))
load(file = paste0(internal.wd,"/Maps_exploitation/Mimicry.Div_protec_prop.RData"))
load(file = paste0(internal.wd,"/Maps_exploitation/mimicry.mean.rarity_protec_prop.RData"))

load(file = paste0(internal.wd,"/Maps_exploitation/Vulnerability_protec_prop.RData"))

# Plot Full version

par()$mar
par(mar = c(5.1, 4.1, 4.1, 10))
plot(y = 1:100, x = 1:100, ylim = c(0, 50), type = "n", 
     ylab = "% of protected communities", xlab = "% of highest scoring communities", 
     main = "Cumulative proportion of \n protected communities \n ranked from highest to lowest scores",
     cex.axis = 1.7, cex.lab = 1.7, axis.args=list(cex.axis=1.7))
abline(h = sp.richness_protec_prop[100], lwd = 2)
lines(x = 1:100, y = sp.richness_protec_prop, lwd = 2, col = rainbow(10)[1])
lines(x = 1:100, y = sp.diversity_protec_prop, lwd = 2, col = rainbow(10)[2])
lines(x = 1:100, y = mean.sp.rarity_protec_prop, lwd = 2, col = rainbow(10)[3])
lines(x = 1:100, y = Faith.PD_protec_prop, lwd = 2, col = rainbow(10)[4])
lines(x = 1:100, y = FP_protec_prop, lwd = 2, col = rainbow(10)[5])
lines(x = 1:100, y = MPD_protec_prop, lwd = 2, col = rainbow(10)[6])
lines(x = 1:100, y = Mimicry.richness_protec_prop, lwd = 2, col = rainbow(10)[7])
lines(x = 1:100, y = Mimicry.Div_protec_prop, lwd = 2, col = rainbow(10)[8])
lines(x = 1:100, y = mimicry.mean.rarity_protec_prop, lwd = 2, col = rainbow(10)[9])
lines(x = 1:100, y = Vulnerability_protec_prop, lwd = 2, col = rainbow(10)[10])

legend(legend = c("Species Richness", "Species Diversity", "Species Rarity", "Faith's PD", "Fair-Proportion", "Mean PD", 
                "Mimicry Richness", "Mimicry Diversity", "Mimicry Rarity", "Vulnerability"), 
       inset=c(-0.6,0), xpd = NA, x = "right",
       cex = 0.8, lty = 1, col = rainbow(10))

# Plot Selected version

# tiff(filename = paste0(internal.wd,"/Maps_exploitation/Cum_prop_plot.tif"))
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Cum_prop_plot.jpeg"), quality = 100)
original_margins <- par()$mar
par(mar = c(5.1, 4.1, 4.1, 15))
plot(y = 1:100, x = 1:100, ylim = c(0, 50), type = "n", 
     ylab = "% of protected communities", xlab = "% of highest scoring communities",
     main = "Cumulative proportion of \n protected communities \n ranked from highest to lowest scores",
     cex.axis = 1.5, cex.lab = 1.5, axis.args=list(cex.axis=1.5))
abline(h = sp.richness_protec_prop[100], lwd = 2)
lines(x = 1:100, y = sp.richness_protec_prop, lwd = 2, lty = 1, col = "red")
lines(x = 1:100, y = mean.sp.rarity_protec_prop, lwd = 2, lty = 2, col = "orange")
lines(x = 1:100, y = Faith.PD_protec_prop, lwd = 2, lty = 1, col = "blue")
lines(x = 1:100, y = MPD_protec_prop, lwd = 2, lty = 2, col = "deepskyblue")
lines(x = 1:100, y = Mimicry.richness_protec_prop, lwd = 2, lty = 1, col = "limegreen")
lines(x = 1:100, y = mimicry.mean.rarity_protec_prop, lwd = 2, lty = 2, col = "darkgreen")
lines(x = 1:100, y = Vulnerability_protec_prop, lwd = 2, lty = 1, col = "black")

legend(legend = c("Species Richness", "Species Rarity", "Faith's PD", "Mean PD", 
                  "Mimicry Richness", "Mimicry Rarity", "Vulnerability"), 
       inset=c(-0.45,0), xpd = NA, x = "right",
       cex = 1, lty = c(1, 2, 1, 2, 1, 2, 1), lwd = 2, col = c("red","orange","blue","deepskyblue","limegreen", "darkgreen", "black"))
par(mar = original_margins)
dev.off()

?tiff

##### Barplot global avec comparaison IN/OUT pour chaque carte ? Problème d'échelle => standardiser tous les index entre 0 et 1 ?


##### MARXAN analysis #####

R CMD INSTALL marxanui_0.1.2.tar.gz

library(marxanui)       # Load the R package

launch_app("import")    # Launch the import app to import your own data

launch_app("marxan")    # Launch the marxan app to run Marxan

launch_app("mxptest")   # Launch the parameter testing app to do BLM, SPF calibration, and target sensitivity testing

launch_app("marzone")   # Launch the marzone app to run MarZone

launch_app("manage")    # Launch the manage app to manage your datasets
