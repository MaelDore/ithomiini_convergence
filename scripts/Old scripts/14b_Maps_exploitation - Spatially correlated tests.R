##### Boxplots tests and Correlation analysis taking into account the spatial autocorrelation

### Preparation ###

# Effacer l'environnement
rm(list = ls())

library(raster)

# Set Wd
internal.wd <- "F:/Documents/Etudes/Fac/Cours/TROPIMUNDO/Stage_S4/Projet_Papillons/R_codes"

# Load masks
load(file = paste0(internal.wd, "/Maps_exploitation/WDPA_light_cropped.RData"))
load(file = paste0(internal.wd, "/Maps_exploitation/WDPA_antimask_shp.RData"))
WDPA <- WDPA_light_cropped

# Color palet for plot
cool = rainbow(50, s = 1, v = 1, start=rgb2hsv(col2rgb('yellow'))[1], end=rgb2hsv(col2rgb('blue'))[1])
warm = rainbow(50, s = 1, v= 1, start=rgb2hsv(col2rgb('red'))[1], end=rgb2hsv(col2rgb('yellow'))[1])
pal_bl_red  = c(rev(cool), rev(warm))


### Building the HII raster 

HII.raster_full = raster(x = paste0(substr(x = internal.wd, start = 0, stop = 66),"/Databases/HII/hii_v2geo/w001001.adf"))
plot(HII.raster_full, col = pal_bl_red)
# Resample the raster to be similar to the other one # Not working because of memory issues...
# Aggregation to lower level need to be done in ArcGIS first
# Load results from ArcGIS
HII.raster <-  raster(x = paste0(substr(x = internal.wd, start = 0, stop = 66),"/Databases/HII/HII_raster_LD/w001001.adf"))
HII.raster <- crop(x = HII.raster, y = Ithomiini.range.raster) # Crop first to make the job easier for the resample function
HII.raster <- resample(x = HII.raster, y = Ithomiini.range.raster, method = "bilinear") # Automatic method to adjust CRS, extent and resolution of a Raster Object ot another one
HII.raster <- round(HII.raster/max(HII.raster[], na.rm = T)*100, 0) # Change units to rescale from 0 to 100
plot(HII.raster, col = pal_bl_red)

summary(HII.raster)
hist(HII.raster) # Few points above 50/60 => can be contrasted for mapping

save(HII.raster, file = paste0(internal.wd, "/Maps_exploitation/HII.raster.RData"))

load(file = paste0(internal.wd, "/Maps_exploitation/HII.raster.RData"))

# Plot
jpeg(filename = paste0(internal.wd, "/Maps/Indices/HII.jpeg"), quality = 100)
plot(HII.raster, col = pal_bl_red,  main = "Human Influence Index",
     cex.axis = 1.7, cex.main = 2, axis.args=list(cex.axis=1.7))
plot(crop_mask_shp, add = T)
dev.off()

HII.masked <- mask(x = HII.raster, mask = WDPA)
jpeg(filename = paste0(internal.wd,"/Maps/Indices_with_WDPA/HII.jpeg"), quality =100)
plot(HII.masked, col = pal_bl_red, main = "Human Influence Index vs. protected areas",
     cex.axis = 1.7, cex.main = 2, axis.args=list(cex.axis=1.7))
plot(crop_mask_shp, add = T)
dev.off()

# Contrasted version

HII.raster.contrasted <- HII.raster
HII.raster.contrasted[HII.raster > 60] <- 60

jpeg(filename = paste0(internal.wd, "/Maps/Indices/HII_contrasted.jpeg"), quality = 100)
plot(HII.raster.contrasted, col = pal_bl_red,  main = "Human Influence Index",
     cex.axis = 1.7, cex.main = 2, axis.args=list(cex.axis=1.7))
plot(crop_mask_shp, add = T)
dev.off()

# Plot par mask
HII.contrasted.masked <- mask(x = HII.raster.contrasted, mask = WDPA)
jpeg(filename = paste0(internal.wd,"/Maps/Indices_with_WDPA/HII_contrasted.jpeg"), quality =100)
plot(HII.contrasted.masked, col = pal_bl_red, main = "Human Influence Index",
     cex.axis = 1.7, cex.main = 2, axis.args=list(cex.axis=1.7))
plot(crop_mask_shp, add = T)
dev.off()


### Extraction of coordinates inside Ithomiini range from raster

load(file = paste0(internal.wd, "/Maps_exploitation/Ithomiini_range_raster.RData"))

IN_raster <- mask(x = Ithomiini.range.raster, mask = WDPA)
OUT_raster <- mask(x = Ithomiini.range.raster, mask = WDPA_antimask_shp)
plot(IN_raster)
plot(OUT_raster)

all_coords <- coordinates(Ithomiini.range.raster)

IN_coords <- all_coords[!is.na(IN_raster[]),]
OUT_coords <- all_coords[!is.na(OUT_raster[]),]

IN.OUT_coords <- rbind(IN_coords, OUT_coords)

save(all_coords, IN_coords, OUT_coords, file = paste0(internal.wd, "/Maps_exploitation/IN.OUT_coords.RData"))
load(file = paste0(internal.wd, "/Maps_exploitation/IN.OUT_coords.RData"))

### Choose subsampling index

sample.all_index <- sample(x = which(!is.na(Ithomiini.range.raster[])), size = 1000, replace = F)
sample.all_coords <- all_coords[sample.all_index,]
sample.IN_index <- sample(x = 1:nrow(IN_coords), size = 1000, replace = F)
sample.IN_coords <- IN_coords[sample.IN_index,]
sample.OUT_index <- sample(x = 1:nrow(OUT_coords), size = 1000, replace = F)
sample.OUT_coords <- OUT_coords[sample.OUT_index,]

sample.IN.OUT_coords <- rbind(sample.IN_coords, sample.OUT_coords)

save(sample.all_index, sample.IN_index, sample.OUT_index, file =  paste0(internal.wd, "/Maps_exploitation/sample.IN.OUT_index.RData"))
save(sample.all_coords, sample.IN_coords, sample.OUT_coords, file =  paste0(internal.wd, "/Maps_exploitation/sample.IN.OUT_coords.RData"))
load(file =  paste0(internal.wd, "/Maps_exploitation/sample.IN.OUT_index.RData"))
load(file =  paste0(internal.wd, "/Maps_exploitation/sample.IN.OUT_coords.RData"))


### Project coords on plan to use in nlme corStructure functions

sample.all_coords_Spobj <- SpatialPoints(sample.all_coords, proj4string = Ithomiini.range.raster@crs)
sample.all_coords_Spobj <- spTransform(sample.all_coords_Spobj, CRS("+proj=utm +zone=20 +ellps=WGS84 +datum=WGS84 +units=km +no_defs")) # Exemple de projection : "+proj=longlat" pour le WGS84
proj_sample.all_coords <- sample.all_coords_Spobj@coords

sample.IN_coords_Spobj <- SpatialPoints(sample.IN_coords, proj4string = Ithomiini.range.raster@crs)
sample.IN_coords_Spobj <- spTransform(sample.IN_coords_Spobj, CRS("+proj=utm +zone=20 +ellps=WGS84 +datum=WGS84 +units=km +no_defs")) # Exemple de projection : "+proj=longlat" pour le WGS84
proj_sample.IN_coords <- sample.IN_coords_Spobj@coords

sample.OUT_coords_Spobj <- SpatialPoints(sample.OUT_coords, proj4string = Ithomiini.range.raster@crs)
sample.OUT_coords_Spobj <- spTransform(sample.OUT_coords_Spobj, CRS("+proj=utm +zone=20 +ellps=WGS84 +datum=WGS84 +units=km +no_defs")) # Exemple de projection : "+proj=longlat" pour le WGS84
proj_sample.OUT_coords <- sample.OUT_coords_Spobj@coords

save(proj_sample.all_coords, proj_sample.IN_coords, proj_sample.OUT_coords, file =  paste0(internal.wd, "/Maps_exploitation/proj_sample_coords.RData"))
load(file =  paste0(internal.wd, "/Maps_exploitation/proj_sample_coords.RData"))


### Compute geographic distance (if find a way to use it in correlation strucutre or autocorrelogram)
?distm
library(geosphere)

# For autocorrelation
dist_all <- distm(sample.all_coords, fun = distGeo) # Génère la matrice symétrique de distance par calcul trigo.
dist_all <- as.dist(dist_all/1000) # Transforme la matrice en matrice triangulaire inférieure pour éviter les doublons (n(n-1)/2 éléments). # Conversion en km
save(dist_all, file = paste0(internal.wd, "/Maps_exploitation/dist_all.RData"))
load(file = paste0(internal.wd, "/Maps_exploitation/dist_all.RData"))

summary(as.numeric(dist_all))
hist(dist_all,breaks=100)
head(x = sort(dist_all), n = 100)

# For comparison IN.OUT
dist_IN.OUT <- distm(sample.IN.OUT_coords, fun = distGeo) # Génère la matrice symétrique de distance par calcul trigo.
dist_IN.OUT <- as.dist(dist_IN.OUT/1000) # Transforme la matrice en matrice triangulaire inférieure pour éviter les doublons (n(n-1)/2 éléments). # Conversion en km
save(dist_IN.OUT, file = paste0(internal.wd, "/Maps_exploitation/dist_IN.OUT.RData"))
load(file = paste0(internal.wd, "/Maps_exploitation/dist_IN.OUT.RData"))

summary(as.numeric(dist_IN.OUT))
hist(dist_IN.OUT,breaks=100)
head(x = sort(dist_IN.OUT), n = 100)

### Plot autocorrelogram on 1 raster

# Load data
load(file = paste0(internal.wd,"/Com.sp.richness.RData"))
load(file = paste0(internal.wd, "/Maps_exploitation/sp.richness.IN.OUT.RData")) 

# Extract the samples
sample.sp.richness <- tot.sp.richness[sample.all_index]
sample.sp.richness.IN <- sp.richness.IN[sample.IN_index]
sample.sp.richness.OUT <- sp.richness.IN[sample.OUT_index]
sample.sp.richness.IN.OUT <- c(sample.sp.richness.IN, sample.sp.richness.OUT)

# Correlogram par bins
library(ncf)

sample_data <- resid.model
sample_data <- sample.sp.richness
sample_data <- sample.sp.richness.IN.OUT

dist <- dist_all
dist <- dist_IN.OUT

coords <- sample.all_coords
coords <- sample.IN.OUT_coords

bins <- round(x= 1 + 3.3*log(x = max(dist), base = 2), digits = 0) # Nombre de bins selon la règle de Struges
increment <- round(max(dist)/bins,0) ; increment

?correlog

correlogram <- ncf::correlog(x = coords[,1], y = coords[,2], z = sample_data, latlon=T, increment= increment, resamp=1000) # Génère le corrélogramme en calculant des distance de grand cercle
par(mfcol=c(2,2)) ; plot(correlogram)  ; abline(h=0)
plot(correlogram$mean.of.class,correlogram$correlation, type="b", col = c("black","red")[(correlogram$p>0.05)+1], ylim = c(-1,1), pch=16, cex=1, lwd=1.5, xlab="Distance (km)", ylab="Moran's I", cex.lab=1.5, cex.axis=1.2) ; abline(h=0)
plot(correlogram$mean.of.class[1:15],correlogram$correlation[1:15], type="b", col = c("black","red")[(correlogram$p>0.05)+1], ylim = c(-1,1), pch=16, cex=1, lwd=1.5, xlab="Distance (km)", ylab="Moran's I", cex.lab=1.5, cex.axis=1.2) ; abline(h=0)
plot(correlogram$mean.of.class[1:10],correlogram$correlation[1:10], type="b", col = c("black","red")[(correlogram$p>0.05)+1], ylim = c(-1,1), pch=16, cex=1, lwd=1.5, xlab="Distance (km)", ylab="Moran's I", cex.lab=1.5, cex.axis=1.2) ; abline(h=0)

jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Correlog/Correlog_SP.richness_FPD.jpeg"), quality =100)
par(mfcol=c(1,1))
plot(main = "Correlogram of residuals \n Species Richness ~ Faith's PD", x = correlogram$mean.of.class[1:15], y = correlogram$correlation[1:15], type="b", col = c("black","red")[(correlogram$p>0.05)+1], ylim = c(-1,1), pch=16, cex=1, lwd=1.5, xlab="Distance (km)", ylab="Moran's I", cex.lab=1.5, cex.axis=1.2) ; abline(h=0)
dev.off()

correlogram$x.intercept # Distance à laquelle l'autocorrelation spatial est nulle (rencontre l'axe des x) (Epperson, 1993)
# 1932km pour sp.richness
# 1313km pour sp.richness ~ Faith's PD

correlogram$p # P.value de chaque bin
correlogram$n # Nombre de paires considérées comme voisines par classes de distance. Vérifier >30.
# Limite => ce corrélogramme ne montre pas le déclin de l'autocorrel. lorsque l'on augmente la distance qui définit le voisinage 
# car il calcule l'autocorrel. au sein de chaque classe où seul les paires dans ces bornes de distances sont considérées 
# comme voisines mais pas les paires des distances inférieures ! 
# Fonction utile pour l'autocorrelation temporelle plutôt que spatiale où l'on s'intéresse à des classes bornées.
# Ici on cherche plutôt à voir l'évol. de l'autocorrel. avec l'augmentation de la distance de voisinage

# Pour définir une distance de voisinage pour un test de Moran global, un modèle autorégressif ou bien générer des SEV à partir d'une matrice de voisinage
# Correlogramme par distances additives = "spline" # Problème => distri de la stats sous modèle null établi par bootstrap et non permutation.
?spline.correlog
maxdist <- 3000 ; increment <- 200 # Choose dist max and increment for "additive" bins
correlogram <- spline.correlog(coords[,1], y = coords[,2], z = sample_data, latlon=T, type = "boot", resamp=1000, xmax=maxdist, npoints=round(maxdist/increment))
par(mfcol=c(1,1)) ; plot(x = correlogram, xmax = maxdist, text = T)

correlogram$real$x.intercept # Distance pour laquelle l'autocorrelation s'annule
# 1813km pour sp.richness
summary(correlogram$boot$boot.summary$x.intercept)

# Plot à la main du spline correlogram mais avec les intervalles de confiances et les points significatifs
xlim.max <- 3000 ; nb.points <- round(xlim.max/increment) # Choix de la distance max à plotter et de l'incrément des points
plot(correlogram$real$predicted$x[1:(nb.points)],correlogram$real$predicted$y[1:nb.points], type="n", pch=16, cex=1, lwd=1.5, xlab="Distance", ylab="Moran's I", cex.lab=1.5, cex.axis=1.2, ylim = c(-1,1), xlim = c(0,xlim.max))
polygon(c(rev(correlogram$boot$boot.summary$predicted$x[1:nb.points]), correlogram$boot$boot.summary$predicted$x[1:nb.points]), c(rev(correlogram$boot$boot.summary$predicted$y[2,1:nb.points]), correlogram$boot$boot.summary$predicted$y[10,1:nb.points]), col = 'grey80', border = NA)
abline(h=0)
lines(x = correlogram$real$predicted$x[1:(nb.points)], y = correlogram$real$predicted$y[1:nb.points], type = "b", pch=16, cex=1, lwd=1.5, lty = 1, col = "black")
lines(x = correlogram$boot$boot.summary$predicted$x[1:nb.points], y =  correlogram$boot$boot.summary$predicted$y[2,1:nb.points], type = "l", lty = 2, col = "red")
lines(x = correlogram$boot$boot.summary$predicted$x[1:nb.points], y =  correlogram$boot$boot.summary$predicted$y[10,1:nb.points], type = "l", lty = 2, col = "red")
for (i in 1:nb.points){
  if ((correlogram$real$predicted$y[i]<correlogram$boot$boot.summary$predicted$y[2,i])|(correlogram$real$predicted$y[i]>correlogram$boot$boot.summary$predicted$y[10,i])){
    points(x = correlogram$real$predicted$x[i], y = correlogram$real$predicted$y[i], col = "red", pch = 16)
  }
}

# Test de Moran sur les résidus... besoin de définir la matrice de voisinage... 
# et au final c'est déjà ce que fait le correlogramme pour différentes valeurs de distance
# donc inutile !

spdep::moran.test

library(ape)
?Moran.I


##### Approche GLS avec structure de covariance modélisée (Devictor et al., 2014 => corExp)
# Besoin de subsampling sinon la matrice de distance est trop fat...

# Load data
load(file = paste0(internal.wd,"/Com.sp.richness.RData"))
load(file = paste0(internal.wd,"/Com.PD.RData"))

# Extract the samples
sample.sp.richness <- tot.sp.richness[sample.all_index]
sample.FPD <- PD.raster[sample.all_index]

library(nlme)

?gls
?corClasses
?corSpatial

?corExp # Relation exponentielle (courbe log)
?corLin # Relation linéaire (droite)
?corGaus # Relation sinusoidale (telle la cumulative df d'une loi Normale)
?corSpher # Relation exponentielle avec plateau
?corRatio # ???


### Version quadratique

m0 <- gls(sample.FPD ~ sample.sp.richness + I(sample.sp.richness^2))
summary(m0)
anova(m0, type = "marginal")
resid.model <- residuals(m0, type = "response")
?Variogram
vario0 <- Variogram(resid.model, distance = dist_all, resType = "pearson", maxDist = 3000)
?plot.Variogram
plot(vario0, smooth = TRUE, ylim = c(0, 1.2))

load(file =  paste0(internal.wd, "/Maps_exploitation/proj_sample_coords.RData"))

data.gls <- as.data.frame(cbind(sample.FPD, sample.sp.richness))

for (i in 1) {
m1 <- gls(data = data.gls, sample.FPD ~ sample.sp.richness + I(sample.sp.richness^2), correlation = corExp(form = ~ proj_sample.all_coords[,1] + proj_sample.all_coords[,2], nugget = TRUE))
print("m1")
m2 <- gls(data = data.gls, sample.FPD ~ sample.sp.richness + I(sample.sp.richness^2), correlation = corGaus(form = ~ proj_sample.all_coords[,1] + proj_sample.all_coords[,2], nugget = TRUE))
print("m2")
m3 <- gls(data = data.gls, sample.FPD ~ sample.sp.richness + I(sample.sp.richness^2), correlation = corSpher(form = ~ proj_sample.all_coords[,1] + proj_sample.all_coords[,2], nugget = TRUE))
print("m3")
m4 <- gls(data = data.gls, sample.FPD ~ sample.sp.richness + I(sample.sp.richness^2), correlation = corLin(form = ~ proj_sample.all_coords[,1] + proj_sample.all_coords[,2], nugget = TRUE))
print("m4")
m5 <- gls(data = data.gls, sample.FPD ~ sample.sp.richness + I(sample.sp.richness^2), correlation = corRatio(form = ~ proj_sample.all_coords[,1] + proj_sample.all_coords[,2], nugget = TRUE))
print("m5")
}
save(m0, m1, m2, m3, m4, m5, file =  paste0(internal.wd, "/Maps_exploitation/Models/Models_FPD_vs_sp.richness_quad.RData"))
load(file =  paste0(internal.wd, "/Maps_exploitation/Models/Models_FPD_vs_sp.richness_quad.RData"))

# Find the best model
AIC(m0, m1, m2, m3, m4, m5)
which.min(AIC(m0, m1, m2, m3, m4, m5)[,2])

Cor_FPD_Sp.richness_AIC_df <- data.frame(c("No structure", "corExp", "corGaus", "corSpher", "corLin", "corRatio")) ; names(Cor_FPD_Sp.richness_AIC_df) <- "Correlation Structure"
Cor_FPD_Sp.richness_AIC_df$AIC <- AIC(m0, m1, m2, m3, m4, m5)
save(Cor_FPD_Sp.richness_AIC_df, file =  paste0(internal.wd, "/Maps_exploitation/Models/Cor_FPD_Sp.richness_AIC_df.RData"))
load(file =  paste0(internal.wd, "/Maps_exploitation/Models/Cor_FPD_Sp.richness_AIC_df.RData"))

?Variogram
# Check the fit of the model to the semi-variogram
vario_best <- Variogram(m1, form = ~ proj_sample.all_coords[,1] + proj_sample.all_coords[,2], resType = "pearson", maxDist = 4000)
plot(vario_best, smooth = FALSE, ylim = c(0, 1.2))

# Plot Variogram on normalized residuals that shoud show no trend if things went well
vario_norm <- Variogram(m1, form = ~ proj_sample.all_coords[,1] + proj_sample.all_coords[,2], resType = "normalized", maxDist = 3000)
plot(vario_norm, smooth = FALSE, ylim = c(0, 1.2))

### Plot the correlogram of residuals before and after taking spatial autocorrelation into consideration

library(ncf)

resid.model <- resid(m0, type = "response") # Sans prise en compte de la strucutre spatiale
resid.model <- resid(m1, type = "response") # Avec prise en compte de la strucutre spatiale

hist(resid.model)

# bins <- round(x= 1 + 3.3*log(x = max(dist), base = 2), digits = 0) # Nombre de bins selon la règle de Struges
# increment <- round(max(dist)/bins,0) ; increment
increment <- 200

?correlog

correlogram <- ncf::correlog(x = proj_sample.all_coords[,1], y = proj_sample.all_coords[,2], z = resid.model, latlon=F, increment = increment, resamp=1000) # Génère le corrélogramme en calculant des distance de grand cercle
par(mfcol=c(2,2)) ; plot(correlogram_m1)  ; abline(h=0)
plot(correlogram$mean.of.class,correlogram$correlation, type="b", col = c("black","red")[(correlogram$p>0.05)+1], ylim = c(-1,1), pch=16, cex=1, lwd=1.5, xlab="Distance (km)", ylab="Moran's I", cex.lab=1.5, cex.axis=1.2) ; abline(h=0)
plot(correlogram$mean.of.class[1:15],correlogram$correlation[1:15], type="b", col = c("black","red")[(correlogram$p>0.05)+1], ylim = c(-1,1), pch=16, cex=1, lwd=1.5, xlab="Distance (km)", ylab="Moran's I", cex.lab=1.5, cex.axis=1.2) ; abline(h=0)
plot(correlogram$mean.of.class[1:10],correlogram$correlation[1:10], type="b", col = c("black","red")[(correlogram$p>0.05)+1], ylim = c(-1,1), pch=16, cex=1, lwd=1.5, xlab="Distance (km)", ylab="Moran's I", cex.lab=1.5, cex.axis=1.2) ; abline(h=0)

# correlogram_m0 <- correlogram
save(correlogram_m0, file = paste0(internal.wd,"/Maps_exploitation/Correlog/Correlog_SP.richness_FPD_Classic_LM.RData"))
# correlogram_m1 <- correlogram
save(correlogram_m1, file = paste0(internal.wd,"/Maps_exploitation/Correlog/Correlog_SP.richness_FPD_GLS_Spatial.RData"))

# Plot Correlog Classic LM
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Correlog/Correlog_SP.richness_FPD_Classic_LM.jpeg"), quality =100)
par(mfcol=c(1,1))
plot(main = "Correlogram of residuals \n Species Richness ~ Faith's PD \n (Classic LM)", x = correlogram_m0$mean.of.class[1:20], y = correlogram_m0$correlation[1:20], type="b", col = c("black","red")[(correlogram_m0$p>0.05)+1], ylim = c(-1,1), pch=16, cex=1, lwd=1.5, xlab="Distance (km)", ylab="Moran's I", cex.lab=1.5, cex.axis=1.2) ; abline(h=0)
dev.off()

# Plot Correlog GLS Spatial
jpeg(filename = paste0(internal.wd,"/Maps_exploitation/Correlog/Correlog_SP.richness_FPD_GLS_Spatial.jpeg"), quality =100)
par(mfcol=c(1,1))
plot(main = "Correlogram of residuals \n Species Richness ~ Faith's PD \ (GLS Spatial)", x = correlogram_m1$mean.of.class[1:20], y = correlogram_m1$correlation[1:20], type="b", col = c("black","red")[(correlogram_m1$p>0.05)+1], ylim = c(-1,1), pch=16, cex=1, lwd=1.5, xlab="Distance (km)", ylab="Moran's I", cex.lab=1.5, cex.axis=1.2) ; abline(h=0)
dev.off()

### Compute R and F-Stats

summary(m1)
p <- summary(m1)$tTable[2,4]
# F-value = SCM/ddlM / SCR/ddlR
F_value <- ((sum((predict(m1)-mean(sample.FPD))^2))/2)/((sum((sample.FPD-predict(m1))^2))/997)

# Compute regular (?) pseudo R² based on the traditional definition in OLS context => R² = 1 - SCE/SCT = SCM/SCT
pseudo.R2 <- 1 - (sum((sample.FPD-predict(m1))^2)/sum((sample.FPD-mean(sample.FPD))^2))
# Compute other R² applicable only in for a linear model
R2 <- cor(sample.FPD,predict(m1))^2

### Plot the model
jpeg(filename = paste0(internal.wd, "/Maps_exploitation/Correl_Plots/Correl_Plot_FPD_sp.richness_quad.RData"), quality = 100)
plot(sample.FPD ~ sample.sp.richness, main = "Correlation Plot \n Faith's PD ~ Species Richness \n (Quadratic model)", ylab = "Faith's Phylogenetic Distance", xlab = "Species Richness")
# abline(coef(m1), lwd = 2, col = "red") # For linear model
order.index <- order(sample.sp.richness)
lines(y = predict(m1)[order.index], x = sample.sp.richness[order.index], col = "red", lwd = 2)
legend(legend = c(paste0("Pseudo R² = ", round(pseudo.R2,2)), paste0("F = ", round(F_value, 0)), paste0("ddl = 2, 997") , paste0("p = 0.001")), x = "bottomright")
dev.off()

### Test to see if the predictions need the correlation structure need to be taken in account. Answer : NO !

load(file = paste0(internal.wd, "/Maps_exploitation/Ithomiini_range_raster.RData"))
?predict.gls

# Generate newdata df
newdata <-  data.frame(tot.sp.richness[]) ; names(newdata) <- "sample.sp.richness"
newdata$sample.FPD <- PD.raster[]
newdata <- newdata[!is.na(Ithomiini.range.raster[]),] # Remove NA

# Extract projected coords of all non NA pixels
full_coords <- coordinates(Ithomiini.range.raster)[!is.na(Ithomiini.range.raster[]),]
full_coords_Spobj <- SpatialPoints(full_coords, proj4string = Ithomiini.range.raster@crs)
full_coords_Spobj <- spTransform(full_coords_Spobj, CRS("+proj=utm +zone=20 +ellps=WGS84 +datum=WGS84 +units=km +no_defs")) # Exemple de projection : "+proj=longlat" pour le WGS84
proj_full_coords <- full_coords_Spobj@coords

?predict.gls
pred_net.FPD <- predict(object = m1, newdata = newdata, correlation = corExp(form = ~ full_coords[,1] + full_coords[,2]))
pred_net.FPD_2 <- predict(object = m1, newdata = newdata)
sum(pred_net.FPD_2 - pred_net.FPD)

pred.raster <- Ithomiini.range.raster
pred.raster[!is.na(pred.raster[])] <- pred_net.FPD

# Aucune différence ! La structure de correlation n'est prise en compte que pour l'estimation des paramètres, mais pas pour les prédictions par la suite...

### Direct predictions of net values from model coefs

pred.raster <- coef(m1)[1] + coef(m1)[2]*tot.sp.richness + coef(m1)[3]*tot.sp.richness^2
plot(pred.raster, col = pal_bl_red)
plot(PD.raster, col = pal_bl_red)
resid.raster <- pred.raster - PD.raster
resid.raster[is.na(Ithomiini.range.raster[])] <- NA
plot(resid.raster, col = pal_bl_red)

# Plot the contrasted version
load(file = paste0(internal.wd, "/crop_mask_shp.RData"))
resid.raster[resid.raster<(-50)] <- -50
resid.raster[resid.raster>50] <- 50
jpeg(filename = paste0(internal.wd, "/Maps_exploitation/Net_Faith_PD.jpeg"), quality = 100)
plot(resid.raster, col = pal_bl_red,  main = "Net Faith's Phylogenetic Diversity")
plot(crop_mask_shp, add = T)
dev.off()


### Models GLS linéaires (pas d'effets quadratiques testés)

# Faire les 45 combinaisons pour récupérer le r et plotter une Heatmap

load(file =  paste0(internal.wd, "/Maps_exploitation/proj_sample_coords.RData"))
load(file =  paste0(internal.wd, "/Maps_exploitation/sample.IN.OUT_index.RData"))

# Load maps of all 11 indices
load(file = paste0(internal.wd,"/Com.sp.richness.RData"))
load(file = paste0(internal.wd,"/Com.sp.diversity.compatible_Jost.RData"))
load(file = paste0(internal.wd,"/Com.sp.mean.rarity.RData"))

load(file = paste0(internal.wd,"/Com.MPD.RData"))
load(file = paste0(internal.wd,"/Com.PD.RData"))
load(file = paste0(internal.wd,"/Com.FP.RData"))

load(file = paste0(internal.wd,"/Com.ring.richness.RData"))
load(file = paste0(internal.wd,"/Com.ring.diversity.compatible_Jost.RData"))
load(file = paste0(internal.wd,"/Com.mimicry.mean.rarity.RData"))

load(file = paste0(internal.wd,"/Com.vulnerability.RData"))

load(file = paste0(internal.wd, "/Maps_exploitation/HII.raster.RData"))

# Generate df for object name and label name

Cor_indices_df <- as.data.frame(c("tot.sp.richness", "sp.diversity.compatible_Jost", "mean.sp.rarity", "MPD.raster", "PD.raster", "FP.raster", "tot.ring.richness", "tot.ring.diversity.compatible_Jost", "mimicry.mean.rarity", "vulnerability", "HII.raster"))
names(Cor_indices_df) <- "Object"
Cor_indices_df$Main_label <- c("Species Richness", "Species Diversity", "Mean Species Rarity", "Mean Phylogenetic Pairwise Distance", "Faith's Phylogenetc Diversity", "Sum of Fair-Proportion", "Mimicry Richness", "Mimicry Diversity", "Mean Mimicry Rarity", "Vulnerability", "Human Influence Index")
Cor_indices_df$Y_label <- c("Species Richness", "Jost's Effective Species Richness", "Mean Species Rarity", "Mean Phylogenetic Pairwise Distance", "Faith's Phylogenetc Diversity", "Sum of Fair-Proportion", "Nb of Mimicry rings", "Jost's Effective Mimicry Richness", "Mean Mimicry Rarity", "Vulnerability", "HII (%)")

# Create a loop that test, compute F/R²/p and plot for all possible combinations

combinaisons <- t(combn(x = 1:11, m = 2, simplify = T))
R_coef_mat <- matrix(nrow = 11, ncol = 11, data = NA)


library(nlme)

for (i in 1:55) {
# for (i in 1:nrow(combinaisons)) {
  comb <- combinaisons[i,]
  j <- comb[1] # Index A
  k <- comb[2] # Index B
  
  
  # Extract sample data from raster of index A
  sample.A <- eval(parse(text = paste0(Cor_indices_df$Object[j], "[sample.all_index]")))
  # Extract sample data from raster of index B
  sample.B <- eval(parse(text = paste0(Cor_indices_df$Object[k], "[sample.all_index]")))
  
  data.gls <- as.data.frame(cbind(sample.A, sample.B, proj_sample.all_coords))
  data.gls <- na.omit(data.gls)
  
  # Modeling
  # gls.model <- gls(data = data.gls, sample.A ~ sample.B, correlation = corExp(form = ~ x + y, nugget = TRUE), na.action = na.omit)
  # save(gls.model, file =  paste0(internal.wd, "/Maps_exploitation/Models/Models_", Cor_indices_df$Object[j], "_vs_" , Cor_indices_df$Object[k], ".RData"))
  load(file =  paste0(internal.wd, "/Maps_exploitation/Models/Models_", Cor_indices_df$Object[j], "_vs_" , Cor_indices_df$Object[k], ".RData"))
  
  # Modeling H0
  # gls.model.H0 <- gls(data = data.gls, sample.A ~ 1, correlation = corExp(form = ~ x + y, nugget = TRUE), na.action = na.omit)
  # save(gls.model.H0, file =  paste0(internal.wd, "/Maps_exploitation/Models/Models_H0_", Cor_indices_df$Object[j], "_vs_" , Cor_indices_df$Object[k], ".RData"))
  # load(file =  paste0(internal.wd, "/Maps_exploitation/Models/Models_H0_", Cor_indices_df$Object[j], "_vs_" , Cor_indices_df$Object[k], ".RData"))
  
  ### Compute p-value, r, R² and F-Stats
  
  # F-value = SCM/ddlM / SCR/ddlR
  F_value <- ((sum((predict(gls.model)-mean(data.gls$sample.A))^2))/2)/((sum((data.gls$sample.A-predict(gls.model))^2))/997)
  p <- df(x = F_value, df1 = 2, df2 = 997)
  
  # T-value de la pente et p-value associée
  T_value <- summary(gls.model)$tTable[2,3]
  p_T <- summary(gls.model)$tTable[2,4]
  
  dt(x = 0.6023832, df = 2)
  
  # Test du modèle par likelihood
  # Problème de la paramétrisation via RELM ? Voir cours STAR...
  # Delta.lik <- gls.model$logLik - gls.model.H0$logLik
  # p_Khi <- dchisq(x = Delta.lik, df = 1)
  
  # Compute other R², applicable only for a linear model
  R2 <- cor(data.gls$sample.A, predict(gls.model))^2
  # Get the sign of the relationship
  if (coef(gls.model)[2]<0) {
    R2 <- (-1)*R2
  }
  R_coef_mat[j,k] <- R2
  R_coef_mat[k,j] <- R2
  save(R_coef_mat, file = paste0(internal.wd, "/Maps_exploitation/R_coef_mat.RData"))
  
  ### Plot the model A~B
  jpeg(filename = paste0(internal.wd, "/Maps_exploitation/Correl_Plots/Correl_Plot_", Cor_indices_df$Object[k],"_", Cor_indices_df$Object[j],".jpeg"), quality = 100)
  original_ext_margins <- par()$oma
  par(oma = c(0,4,0,0))
  plot(data.gls$sample.A ~ data.gls$sample.B,
       main = paste0("Correlation Plot \n", Cor_indices_df$Main_label[j], " ~ ", Cor_indices_df$Main_label[k]),
       ylab = Cor_indices_df$Y_label[j], xlab = Cor_indices_df$Y_label[k],
       cex.axis = 1.7, cex.main = 1.5, cex.lab = 1.7, axis.args=list(cex.axis=1.7))
  abline(coef(gls.model), lwd = 2, col = "red") # For linear model
  legend(legend = c(paste0("R² = ", abs(round(R2,2))), paste0("F = ", round(F_value, 0)), paste0("p = ", round(p,3)), paste0("t = ", round(T_value, 2)), paste0("p = ", round(p_T, 3))), x = "bottomright")
  par(oma = original_ext_margins)
  dev.off()
  
  ### Plot the model B~A
  jpeg(filename = paste0(internal.wd, "/Maps_exploitation/Correl_Plots/Correl_Plot_", Cor_indices_df$Object[j],"_", Cor_indices_df$Object[k],".jpeg"), quality = 100)
  original_ext_margins <- par()$oma
  par(oma = c(0,4,0,0))
  plot(data.gls$sample.B ~ data.gls$sample.A, 
       main = paste0("Correlation Plot \n", Cor_indices_df$Main_label[k], " ~ ", Cor_indices_df$Main_label[j]), 
       ylab = Cor_indices_df$Y_label[k], xlab = Cor_indices_df$Y_label[j],
       cex.axis = 1.7, cex.main = 1.5, cex.lab = 1.7, axis.args=list(cex.axis=1.7))
  abline(a = (-coef(gls.model)[1])/coef(gls.model)[2], b = 1/coef(gls.model)[2], lwd = 2, col = "red") # For linear model
  legend(legend = c(paste0("R² = ", abs(round(R2,2))), paste0("F = ", round(F_value, 0)), paste0("p = ", round(p,3)), paste0("t = ", round(T_value, 2)), paste0("p = ", round(p_T, 3))), x = "bottomright")
  par(oma = original_ext_margins)
  dev.off()
  
  cat(paste0(Sys.time(), " - Model n°", i, "\n"))
}

# R_coef_mat[9,10] <- R_coef_mat[10,9] <- 0.05

rownames(R_coef_mat) <- c("Species Richness", "Species Diversity", "Mean Species Rarity", "MPD", "Faith's PD", "Sum of Fair-Proportion", "Mimicry Richness", "Mimicry Diversity", "Mean Mimicry Rarity", "Vulnerability", "Human Influence Index")
colnames(R_coef_mat) <- c("Species Richness", "Species Diversity", "Mean Species Rarity", "MPD", "Faith's PD", "Sum of Fair-Proportion", "Mimicry Richness", "Mimicry Diversity", "Mean Mimicry Rarity", "Vulnerability", "Human Influence Index")

diag(R_coef_mat) <- 1

save(R_coef_mat, file = paste0(internal.wd, "/Maps_exploitation/R_coef_mat.RData"))
load(file = paste0(internal.wd, "/Maps_exploitation/R_coef_mat.RData"))

# R² heat map
library(corrgram)
jpeg(filename = paste0(internal.wd, "/Maps_exploitation/Correl_Plots/Heat_Map_Rsq.RData"), quality = 100)
corrgram(x = R_coef_mat, type = "cor", order = F, lower.panel = panel.shade,  upper.panel = panel.cor, diag.panel = NULL, col.regions = colorRampPalette(c("navy", "royalblue", "white", "orange", "red"))) # pour plotter les correlations entre variables de manière stylée
dev.off()

# Pearson's r heatmap
neg.index <- R_coef_mat<0
Pearson_R_coef_mat <- sqrt(abs(R_coef_mat))
Pearson_R_coef_mat[neg.index] <- -Pearson_R_coef_mat[neg.index]
Pearson_R_coef_mat

# Pearson's r heat map
library(corrgram)
jpeg(filename = paste0(internal.wd, "/Maps_exploitation/Correl_Plots/Heat_Map_R_Pearson.RData"), quality = 100)
corrgram(x = Pearson_R_coef_mat, type = "cor", order = F, lower.panel = panel.shade,  upper.panel = panel.cor, diag.panel = NULL, col.regions = colorRampPalette(c("navy", "royalblue", "white", "orange", "red"))) # pour plotter les correlations entre variables de manière stylée
dev.off()

# Dendrogram des Indices

# To compute on real R²
# R_coef_mat <- abs(R_coef_mat)

jpeg(filename = paste0(internal.wd, "/Maps_exploitation/Correl_Plots/Heat_Map_R_Sq_Dendro.jpeg"), quality = 100)
original_ext_margins <- par()$oma
par(oma = c(7,0,0,7))
heatmap(x = R_coef_mat, hclustfun = hclust, symm = T, col = pal_bl_red)
par(oma = original_ext_margins)
dev.off()

?hclust # Method par défaut = "complete linkage"

# Scale for the heatmap
Ithomiini.range.raster@data@values[1] <- 0
tiff(filename = paste0(internal.wd, "/Maps_exploitation/Correl_Plots/Heat_Map_Scale.tiff"))
plot(Ithomiini.range.raster, col = pal_bl_red,
     axis.args=list(cex.axis=1.7))
dev.off()


##### GAM approach (Zupan et al., 2014)

# Utilise les coordonnées géographiques comme prédicteurs inclus avec un smooth
?gam

x_cor <- coordinates(PD.raster)[,1]
y_cor <- coordinates(PD.raster)[,2]

library(mgcv)
model <- mgcv::gam(PD.raster[] ~ tot.sp.richness[] + s(x_cor, y_cor)) # s() pour smooth la variable explicative
summary(model) ; plot(model) # Permet de visualiser la forme de la relation sous forme de courbe lissée et de détecter d'éventuel effet quadratique à tester en modèle LM/GLM/MM/GMM classiques via anova(mod1,mod2)


##### Test correlation avec functions package raster => ne prend pas en compte la strucutre spatiale !!!
load(file = paste0(internal.wd,"/Com.sp.richness.RData"))

load(file = paste0(internal.wd,"/Com.PD.RData"))
cor.test(x = tot.sp.richness[], y = PD.raster[], method = "spearman", exact = F)
# Ne prend pas en compte la strucutre spatiale...

?corLocal # Pour faire des tests au sein d'une moving window afin d'obtenir un raster qui montre la correlation locale
# ngb = size of moving windows (odd number)
local.cor <- corLocal(x = tot.sp.richness, y = PD.raster, method = "spearman", ngb = 5, test = T)
plot(local.cor)
local.cor.p <- local.cor[[2]]
local.cor.p[local.cor.p>0.05] <- 1
local.cor.p[local.cor.p<=0.05] <- 0
plot(local.cor.p)
